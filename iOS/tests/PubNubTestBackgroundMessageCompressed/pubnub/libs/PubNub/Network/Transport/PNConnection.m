//
//  PNConnection.m
//  pubnub
//
//  This is core class for communication over
//  the network with PubNub services.
//  It allow to establish socket connection and
//  organize write packet requests into FIFO queue.
//
//  Created by Sergey Mamontov on 12/10/12.
//
//

#import "PNConnection.h"
#import <SystemConfiguration/SystemConfiguration.h>
#import <Security/SecureTransport.h>
#import "PNConnection+Protected.h"
#import "PNResponseDeserialize.h"
#import "PNResponseProtocol.h"
#import "PubNub+Protected.h"
#import "PNWriteBuffer.h"
#import "PNHelper.h"


// ARC check
#if !__has_feature(objc_arc)
#error PubNub connection must be built with ARC.
// You can turn on ARC for only PubNub files by adding '-fobjc-arc' to the build phase for each of its files.
#endif


#pragma mark Structures

typedef NS_OPTIONS(NSUInteger, PNConnectionActionSourceFlag)  {

    // Flag which allow to set action has been generated by 'wake up' timer or not
    PNConnectionWakeUpTimer = 1 << 0,

    // Flag which allow to set whether action has been generated by SSL layer from error handling or not
    PNConnectionSSL = 1 << 1,

    // Flag which allow to set whether action has been generated from socket error handling or not
    PNConnectionSocket = 1 << 2
};

typedef NS_OPTIONS(NSUInteger, PNConnectionActionFlag)  {

    // Flag which allow to set whether client is reconnecting at this moment or not
    PNConnectionReconnect = 1 << 3,

    // Flag which allow to set whether client should connect back as soon as disconnection will be completed or not
    PNConnectionReconnectOnDisconnect = 1 << 4,

    // Flag which allow to set whether client should disconnect or not
    PNConnectionDisconnect = 1 << 5
};

typedef NS_OPTIONS(NSUInteger, PNConnectionActionOwnerFlag)  {

    // Flag which allow to set whether action on connection has been triggered by user or not
    PNByUserRequest = 1 << 6,

    // Flag which allow to set whether action on connection has been triggered by internal code or not
    PNByInternalRequest = 1 << 7,

    // Flag which allow to set whether action on connection has been triggered by server or not
    PNByServerRequest = 1 << 8
};

typedef NS_OPTIONS(NSUInteger, PNConnectionStateFlag)  {

    // Flag which allow to set whether read stream configuration started or not
    PNReadStreamConfiguring = 1 << 9,

    // Flag which allow to set whether write stream configuration started or not
    PNWriteStreamConfiguring = 1 << 10,

    // Flag which allow to set whether connection configuration started or not
    PNConnectionConfiguring = (PNReadStreamConfiguring | PNWriteStreamConfiguring),

    // Flag which allow to set whether read stream configured or not
    PNReadStreamConfigured = 1 << 11,

    // Flag which allow to set whether write stream configured or not
    PNWriteStreamConfigured = 1 << 12,

    // Flag which allow to set whether connection configured or not
    PNConnectionConfigured = (PNReadStreamConfigured | PNWriteStreamConfigured),

    // Flag which allow to set whether read stream is connecting right now or not
    PNReadStreamConnecting = 1 << 13,

    // Flag which allow to set whether write stream is connecting right now or not
    PNWriteStreamConnecting = 1 << 14,

    // Flag which allow to set whether client is connecting at this moment or not
    PNConnectionConnecting = (PNReadStreamConnecting | PNWriteStreamConnecting),

    // Flag which allow to set whether read stream is connected right now or not
    PNReadStreamConnected = 1 << 15,

    // Flag which allow to set whether write stream is connected right now or not
    PNWriteStreamConnected = 1 << 16,

    // Flag which allow to set whether connection channel is preparing to establish connection
    PNConnectionPrepareToConnect = 1 << 17,

    // Flag which allow to set whether client is connected or not
    PNConnectionConnected = (PNReadStreamConnected | PNWriteStreamConnected),

    // Flag which allow to set whether connection is suspended or not or not
    PNConnectionResuming = 1 << 18,

    // Flag which allow to set whether read stream is disconnecting right now or not
    PNReadStreamDisconnecting = 1 << 19,

    // Flag which allow to set whether write stream is disconnecting right now or not
    PNWriteStreamDisconnecting = 1 << 20,

    // Flag which allow to set whether client is disconnecting at this moment or not
    PNConnectionDisconnecting = (PNReadStreamDisconnecting | PNWriteStreamDisconnecting),

    // Flag which allow to set whether connection is suspending or not or not
    PNConnectionSuspending = 1 << 21,

    // Flag which allow to set whether read stream is disconnected right now or not
    PNReadStreamDisconnected = 1 << 22,

    // Flag which allow to set whether write stream is disconnected right now or not
    PNWriteStreamDisconnected = 1 << 23,

    // Flag which allow to set whether client is disconnected at this moment or not
    PNConnectionDisconnected = (PNReadStreamDisconnected | PNWriteStreamDisconnected),

    // Flag which stores all states which is responsible for connection 'reconnect' state
    PNConnectionReconnection = (PNConnectionReconnect | PNConnectionReconnectOnDisconnect),

    // Flag which allow to set whether connection is suspended or not or not
    PNConnectionSuspended = 1 << 24,

    // Flag which allow to set whether connection should schedule next requests or not
    PNConnectionProcessingRequests = 1 << 25
};

typedef NS_OPTIONS(NSUInteger, PNConnectionDataSendingStateFlag)  {

    // Flag which allow to set whether action on connection has been triggered by user or not
    PNSendingData = 1 << 26
};

typedef NS_OPTIONS(NSUInteger, PNConnectionErrorStateFlag)  {

    // Flag which allow to set whether error occurred on read stream or not
    PNReadStreamError = 1 << 27,

    // Flag which allow to set whether error occurred on write stream or not
    PNWriteStreamError = 1 << 28,

    // Flag which allow to set whether client is experiencing some error or not
    PNConnectionError = (PNReadStreamError | PNWriteStreamError)
};

typedef NS_OPTIONS(NSUInteger, PNConnectionCleanStateFlag)  {

    // Flag which can be used to clean configuration states related to read stream
    PNReadStreamCleanConfiguration = (PNReadStreamConfiguring | PNReadStreamConfigured),

    // Flag which can be used to clean connection states related to read stream
    PNReadStreamCleanConnection = (PNReadStreamConnecting | PNReadStreamConnected),

    // Flag which can be used to clean connection states related to read stream
    PNReadStreamCleanDisconnection = (PNReadStreamDisconnecting | PNReadStreamDisconnected),

    // Flag which can be used to clean all states related to read stream
    PNReadStreamCleanAll = (PNReadStreamCleanConfiguration | PNReadStreamCleanConnection |
                            PNReadStreamCleanDisconnection | PNReadStreamError),

    // Flag which can be used to clean configuration states related to write stream
    PNWriteStreamCleanConfiguration = (PNWriteStreamConfiguring | PNWriteStreamConfigured),

    // Flag which can be used to clean connection states related to write stream
    PNWriteStreamCleanConnection = (PNWriteStreamConnecting | PNWriteStreamConnected),

    // Flag which can be used to clean connection states related to write stream
    PNWriteStreamCleanDisconnection = (PNWriteStreamDisconnecting | PNWriteStreamDisconnected),

    // Flag which can be used to clean all states related to write stream
    PNWriteStreamCleanAll = (PNWriteStreamCleanConfiguration | PNWriteStreamCleanConnection |
                             PNWriteStreamCleanDisconnection | PNWriteStreamError),

    // Flag which allow to clean up connection 'reconnection' state
    PNConnectionCleanReconnection = PNConnectionReconnection,

    // Flag which allow to set whether client is experiencing some error or not
    PNConnectionErrorCleanAll = (PNReadStreamError | PNWriteStreamError)
};

typedef enum _PNConnectionSSLConfigurationLevel {

    // This option will check all information on remote origin SSL certificate to ensure in authority
    PNConnectionSSLConfigurationStrict,

    // This option will skip most of validations and as fact will allow to work with server which uses invalid SSL
    // certificate or certificate from another server
    PNConnectionSSLConfigurationBarelySecure,

    // This option will tell that connection should be opened w/o SSL (if user won't to discard security options)
    PNConnectionSSLConfigurationInsecure,
} PNConnectionSSLConfigurationLevel;

struct PNConnectionIdentifiersStruct PNConnectionIdentifiers = {
    
    .messagingConnection = @"PNMessagingConnectionIdentifier",
    .serviceConnection = @"PNServiceConnectionIdentifier"
};


#pragma mark - Static

// Stores reference on created connection instances which can be used/reused
static NSMutableDictionary *_connectionsPool = nil;
static dispatch_once_t onceToken;

// Delay which is used by wake up timer to fire
static int64_t const kPNWakeUpTimerInterval = 5;

// Default origin host connection port
static UInt32 const kPNOriginConnectionPort = 80;

// Default origin host SSL connection port
static UInt32 const kPNOriginSSLConnectionPort = 443;

// Default data buffer size (Default: 32kb)
static int const kPNStreamBufferSize = 32768;

// Default connection attempt timeout (Default: 10s)
static int const kPNConnectionTimeout = 10.0f;

// Delay after which connection should retry
static int64_t const kPNConnectionRetryDelay = 2;
static NSTimeInterval const kPNConnectionRetryFastDelay = 0.1f;

// Maximum retry count which can be performed for configuration operation
static NSUInteger const kPNMaximumConfigurationRetryCount = 3;

// Maximum connection retry count which can be performed before library will report connection error
static NSUInteger const kPNMaximumConnectionRetryCount = 3;


#pragma mark - Private interface methods

@interface PNConnection ()

#pragma mark - Properties

// Stores connection name (identifier)
@property (nonatomic, copy) NSString *name;

// Connection configuration information
@property (nonatomic, strong) PNConfiguration *configuration;

// Stores reference on response deserializer which will parse response into objects array and update provided data to
// insert offset on amount of parsed data
@property (nonatomic, strong) PNResponseDeserialize *deserializer;

// Stores reference on binary data object which stores server response from socket read stream
@property (nonatomic, strong) NSMutableData *retrievedData;

// Stores reference on binary data object which temporary stores data received from socket read stream (used while
// deserializer is working)
@property (nonatomic, strong) NSMutableData *temporaryRetrievedData;

// Stores reference on buffer which should be sent to the PubNub service via socket
@property (nonatomic, strong) PNWriteBuffer *writeBuffer;

@property (nonatomic, assign) NSUInteger configurationRetryCount;
@property (nonatomic, assign) NSUInteger connectionRetryCount;

// Stores connection channel state
@property (nonatomic, assign) unsigned long state;

// Stores reference on timer which should awake connection channel if it doesn't reconnect back because of some
// race of states and conditions
@property (nonatomic, pn_dispatch_property_ownership) dispatch_source_t wakeUpTimer;
@property (nonatomic, assign, getter = isWakeUpTimerSuspended) BOOL wakeUpTimerSuspended;

@property (nonatomic, strong) NSTimer *connectionTimeoutTimer;

// Socket streams and state
@property (nonatomic, assign) CFReadStreamRef socketReadStream;
@property (nonatomic, assign) CFWriteStreamRef socketWriteStream;
@property (nonatomic, assign, getter = isWriteStreamCanHandleData) BOOL writeStreamCanHandleData;

// Socket streams configuration and security
@property (nonatomic, strong) NSDictionary *proxySettings;
@property (nonatomic, assign) CFMutableDictionaryRef streamSecuritySettings;
@property (nonatomic, assign) PNConnectionSSLConfigurationLevel sslConfigurationLevel;


#pragma mark - Class methods

/**
 * Retrieve reference on connection with specified identifier from connections pool
 */
+ (PNConnection *)connectionFromPoolWithIdentifier:(NSString *)identifier;

/**
 * Store connection instance inside connections pool
 */
+ (void)storeConnection:(PNConnection *)connection withIdentifier:(NSString *)identifier;

/**
 * Returns reference on dictionary of connections (it will be created on runtime)
 */
+ (NSMutableDictionary *)connectionsPool;


#pragma mark - Instance methods

/**
 * Perform connection initialization with user-provided configuration (they will be obtained from PubNub client)
 */
- (id)initWithConfiguration:(PNConfiguration *)configuration;


#pragma mark - Streams management methods

/**
 * Will create read/write pair streams to specific host at
 */
- (BOOL)prepareStreams;

- (void)disconnectOnInternalRequest;

/**
 * Will destroy both read and write streams
 */
- (void)destroyStreams;

/**
 * Allow to configure read stream with set of parameters like:
 *   - proxy
 *   - security (SSL)
 * If stream already configured, it won't accept any new settings.
 */
- (void)configureReadStream:(CFReadStreamRef)readStream;
- (void)openReadStream:(CFReadStreamRef)readStream;
- (void)disconnectReadStream:(CFReadStreamRef)readStream;
- (void)destroyReadStream:(CFReadStreamRef)readStream;

/**
 * Process response which was fetched from read stream so far
 */
- (void)processResponse;

/**
 * Read out content which is waiting in read stream
 */
- (void)readStreamContent;

/**
 * Allow to complete write stream configuration (additional settings will be transferred from paired read stream on
 * configuration). If stream already configured, it won't accept any new settings.
 */
- (void)configureWriteStream:(CFWriteStreamRef)writeStream;
- (void)openWriteStream:(CFWriteStreamRef)writeStream;
- (void)disconnectWriteStream:(CFWriteStreamRef)writeStream;
- (void)destroyWriteStream:(CFWriteStreamRef)writeStream;

/**
 * Retrieve and prepare next request which should be sent
 */
- (void)prepareNextRequestPacket;

/**
 * Writes buffer portion into socket
 */
- (void)writeBufferContent;


#pragma mark - Handler methods

/**
 * Called every time when one of streams (read/write) successfully open connection
 */
- (void)handleStreamConnection;

/**
 * Called every time when one of streams (read/write) disconnected
 */
- (void)handleStreamClose;

/**
 * Called each time when new portion of data available in socket read stream for reading
 */
- (void)handleReadStreamHasData;

/**
 * Called each time when write stream is ready to accept data from PubNub client
 */
- (void)handleWriteStreamCanAcceptData;

/**
 * Called when client is about to close write stream and we need to do something with write buffer if it was assigned
 */
- (void)handleRequestSendingCancelation;

/**
 * Called each time when server close stream because of timeout
 */
- (void)handleStreamTimeout;

- (void)handleTimeoutTimer:(NSTimer *)timer;

/**
 * Called each time when wake up timer is fired
 */
- (void)handleWakeUpTimer;

/**
 * Converts stream status enum value into string representation
 */
- (NSString *)stringifyStreamStatus:(CFStreamStatus)status;

- (void)handleStreamError:(CFErrorRef)error;
- (void)handleStreamError:(CFErrorRef)error shouldCloseConnection:(BOOL)shouldCloseConnection;
- (void)handleStreamSetupError;
- (void)handleRequestProcessingError:(CFErrorRef)error;


#pragma mark - Misc methods

/**
 * Start/stop connection timeout timer
 */
- (void)startTimeoutTimer;
- (void)stopTimeoutTimer;

/**
 * Construct/reuse and launch/resume/suspend/stop 'wakeup' timer to help restore connection if it will be required
 */
- (void)startWakeUpTimer;
- (void)suspendWakeUpTimer;
- (void)resumeWakeUpTimer;
- (void)stopWakeUpTimer;
- (void)resetWakeUpTimer;

/**
 * Check whether specified error is from POSIX domain and report that error is caused by connection failure or not
 */
- (BOOL)isConnectionIssuesError:(CFErrorRef)error;
- (BOOL)isConnectionUplinkError:(CFErrorRef)error;

/**
 * Check whether specified error is from OSStatus error domain and report that error is caused by SSL issue
 */
- (BOOL)isSecurityTransportError:(CFErrorRef)error;
- (BOOL)isInternalSecurityTransportError:(CFErrorRef)error;
- (BOOL)isTemporaryError:(CFErrorRef)error;
- (BOOL)isServerError:(CFErrorRef)error;

- (CFStreamClientContext)streamClientContext;

/**
 * Retrieving global network proxy configuration
 */
- (void)retrieveSystemProxySettings;

/**
 * Stream error processing methods
 */
- (PNError *)processStreamError:(CFErrorRef)error;

/**
 * Print our current connection state
 */
- (NSString *)stateDescription;


@end


#pragma mark - Public interface methods

@implementation PNConnection

#pragma mark - Class methods

+ (PNConnection *)connectionWithIdentifier:(NSString *)identifier {

    // Try to retrieve connection from pool
    PNConnection *connection = [self connectionFromPoolWithIdentifier:identifier];

    if (connection == nil) {

        connection = [[[self class] alloc] initWithConfiguration:[PubNub sharedInstance].configuration];
        connection.name = identifier;
        [self storeConnection:connection withIdentifier:identifier];
    }


    return connection;
}

+ (PNConnection *)connectionFromPoolWithIdentifier:(NSString *)identifier {

    return [[self connectionsPool] valueForKey:identifier];
}

+ (void)storeConnection:(PNConnection *)connection withIdentifier:(NSString *)identifier {

    [[self connectionsPool] setValue:connection forKey:identifier];
}

+ (void)destroyConnection:(PNConnection *)connection {

    if (connection != nil) {

        // Iterate over the list of connection pool and remove connection from it
        NSMutableArray *connectionIdentifiersForDelete = [NSMutableArray array];
        [[self connectionsPool] enumerateKeysAndObjectsUsingBlock:^(id connectionIdentifier, id connectionFromPool,
                                                                    BOOL *connectionEnumeratorStop) {

            // Check whether found connection in connection pool or not
            if (connectionFromPool == connection) {

                // Adding identifier to the list of keys which should be removed (there can be many keys for single
                // connection because of performance and network issues on iOS)
                [connectionIdentifiersForDelete addObject:connectionIdentifier];
            }
        }];

        [[self connectionsPool] removeObjectsForKeys:connectionIdentifiersForDelete];
    }
}

+ (void)closeAllConnections {

    // Check whether has some connection in pool or not
    if ([_connectionsPool count] > 0) {

        // Store list of connections before purge connections pool
        NSArray *connections = [_connectionsPool allValues];

        // Clean up connections pool
        [_connectionsPool removeAllObjects];


        // Close all connections
        [connections makeObjectsPerformSelector:@selector(disconnectOnInternalRequest)];
    }
}

+ (NSMutableDictionary *)connectionsPool {

    dispatch_once(&onceToken, ^{

        _connectionsPool = [NSMutableDictionary new];
    });


    return _connectionsPool;
}

+ (void)resetConnectionsPool {

    onceToken = 0;

    // Reset connections
    if ([_connectionsPool count]) {

        [[_connectionsPool allValues] makeObjectsPerformSelector:@selector(prepareForTermination) withObject:nil];
        [[_connectionsPool allValues] makeObjectsPerformSelector:@selector(setDataSource:) withObject:nil];
        [[_connectionsPool allValues] makeObjectsPerformSelector:@selector(setDelegate:) withObject:nil];
    }

    _connectionsPool = nil;
}


#pragma mark - Instance methods

- (id)initWithConfiguration:(PNConfiguration *)configuration {

    // Check whether initialization was successful or not
    if ((self = [super init])) {

        // Perform connection initialization
        self.configuration = configuration;
        self.deserializer = [PNResponseDeserialize new];

        // Set initial connection state
        [PNBitwiseHelper addTo:&_state bit:PNConnectionDisconnected];
        
        // Perform streams initial options and security initializations
        [self prepareStreams];
    }


    return self;
}


#pragma mark - Requests queue execution management

- (void)scheduleNextRequestExecution {
    
    [PNBitwiseHelper addTo:&_state bit:PNConnectionProcessingRequests];

    // Ensure that both streams connected at this moment and connection doesn't try to close or suspend
    if ([self isConnected] && ![self isDisconnecting] && ![self isSuspending]) {

        // Check whether sending data at this moment or not
        if (![PNBitwiseHelper is:self.state containsBit:PNSendingData] || ![self.writeBuffer isSendingBytes]) {

            if (self.writeBuffer == nil) {
                
                [PNBitwiseHelper removeFrom:&_state bit:PNSendingData];
                [self prepareNextRequestPacket];
            }
            else {

                [self.writeBuffer reset];
            }

            if (self.writeBuffer != nil) {

                // Try to initiate request sending process
                [self writeBufferContent];
            }
        }
        else {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] ALREADY SENDING DATA (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];
        }
    }
}

- (void)unscheduleRequestsExecution {
    
    [PNBitwiseHelper removeFrom:&_state bit:PNConnectionProcessingRequests];

    [self handleRequestSendingCancelation];
}


#pragma mark - Streams callback methods

void readStreamCallback(CFReadStreamRef stream, CFStreamEventType type, void *clientCallBackInfo) {

    NSCAssert([(__bridge id)clientCallBackInfo isKindOfClass:[PNConnection class]],
              @"{ERROR}[READ] WRONG CLIENT INSTANCE HAS BEEN SENT AS CLIENT");
    PNConnection *connection = (__bridge PNConnection *)clientCallBackInfo;

    NSString *status = [connection stringifyStreamStatus:CFReadStreamGetStatus(stream)];

    switch (type) {

        // Stream successfully opened
        case kCFStreamEventOpenCompleted:
            {
                [PNLogger logConnectionInfoMessageFrom:connection message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@::READ] STREAM OPENED (%@)(STATE: %lu)",
                            connection.name ? connection.name : connection, status, connection.state];
                }];

                [PNBitwiseHelper removeFrom:&(connection->_state) bit:PNReadStreamCleanDisconnection];
                [PNBitwiseHelper addTo:&(connection->_state) bit:PNReadStreamConnected];

                [connection handleStreamConnection];
            }
            break;

        // Read stream has some data which arrived from remote server
        case kCFStreamEventHasBytesAvailable:
            {
                [PNLogger logConnectionInfoMessageFrom:connection message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@::READ] HAS DATA FOR READ OUT (%@)(STATE: %lu)",
                            connection.name ? connection.name : connection, status, connection.state];
                }];

                [connection handleReadStreamHasData];
            }
            break;

        // Some error occurred on read stream
        case kCFStreamEventErrorOccurred:
            {
                [PNLogger logConnectionErrorMessageFrom:connection message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@::READ] ERROR OCCURRED (%@)(STATE: %lu)",
                            connection.name ? connection.name : connection, status, connection.state];
                }];

                // Mark that read stream caught and error
                [PNBitwiseHelper addTo:&(connection->_state) bit:PNReadStreamError];

                CFErrorRef error = CFReadStreamCopyError(stream);
                [connection handleStreamError:error shouldCloseConnection:YES];

                [PNHelper releaseCFObject:&error];
            }
            break;

        // Server disconnected socket probably because of timeout
        case kCFStreamEventEndEncountered:
            {
                [PNLogger logConnectionInfoMessageFrom:connection message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@::READ] NOTHING TO READ (%@)(STATE: %lu)",
                            connection.name ? connection.name : connection, status, connection.state];
                }];

                [PNBitwiseHelper removeFrom:&(connection->_state) bit:PNReadStreamCleanAll];
                [PNBitwiseHelper addTo:&(connection->_state) bit:PNReadStreamDisconnected];

                [connection handleStreamTimeout];
            }
            break;

        default:
            break;
    }
}

void writeStreamCallback(CFWriteStreamRef stream, CFStreamEventType type, void *clientCallBackInfo) {

    NSCAssert([(__bridge id)clientCallBackInfo isKindOfClass:[PNConnection class]],
              @"{ERROR}[WRITE] WRONG CLIENT INSTANCE HAS BEEN SENT AS CLIENT");
    PNConnection *connection = (__bridge PNConnection *)clientCallBackInfo;

    NSString *status = [connection stringifyStreamStatus:CFWriteStreamGetStatus(stream)];

    switch (type) {

        // Stream successfully opened
        case kCFStreamEventOpenCompleted:
            {
                [PNLogger logConnectionInfoMessageFrom:connection message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] STREAM OPENED (%@)(STATE: %lu)",
                            connection.name ? connection.name : connection, status, connection.state];
                }];

                [PNBitwiseHelper removeFrom:&(connection->_state) bit:PNWriteStreamCleanDisconnection];
                [PNBitwiseHelper addTo:&(connection->_state) bit:PNWriteStreamConnected];

                [connection handleStreamConnection];
            }
            break;

        // Write stream is ready to accept data from data source
        case kCFStreamEventCanAcceptBytes:
            {
                [PNLogger logConnectionInfoMessageFrom:connection message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] READY TO SEND (%@)(STATE: %lu)",
                                      connection.name ? connection.name : connection, status, connection.state];
                }];

                [connection handleWriteStreamCanAcceptData];
            }
            break;

        // Some error occurred on write stream
        case kCFStreamEventErrorOccurred:
            {
                [PNLogger logConnectionErrorMessageFrom:connection message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] ERROR OCCURRED (%@)(STATE: %lu)",
                            connection.name ? connection.name : connection, status, connection.state];
                }];

                // Mark that write stream caught and error
                [PNBitwiseHelper addTo:&(connection->_state) bit:PNWriteStreamError];

                CFErrorRef error = CFWriteStreamCopyError(stream);
                [connection handleStreamError:error shouldCloseConnection:YES];

                [PNHelper releaseCFObject:&error];
            }
            break;

        // Server disconnected socket probably because of timeout
        case kCFStreamEventEndEncountered:
            {
                [PNLogger logConnectionInfoMessageFrom:connection message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] MAYBE STREAM IS CLOSED (%@)(STATE: %lu)",
                            connection.name ? connection.name : connection, status, connection.state];
                }];

                [PNBitwiseHelper removeFrom:&(connection->_state) bit:PNWriteStreamCleanAll];
                [PNBitwiseHelper addTo:&(connection->_state) bit:PNWriteStreamDisconnected];

                [connection handleStreamTimeout];
            }
            break;

        default:
            break;
    }
}


#pragma mark - Connection state

- (BOOL)isConnecting {

    // If at least one of the streams is connecting now treat it all as true
    return ([PNBitwiseHelper is:self.state strictly:YES containsBit:PNConnectionDisconnected] &&
            [PNBitwiseHelper is:self.state containsBit:PNConnectionConnecting]);
}

- (BOOL)isReconnecting {

    // If at least one of the streams is connecting now treat it all as true
    return ([PNBitwiseHelper is:self.state containsBit:PNConnectionConnecting] &&
            [PNBitwiseHelper is:self.state containsBit:PNConnectionReconnection]);
}

- (BOOL)shouldReconnect {

    return [PNBitwiseHelper is:self.state containsBit:PNConnectionReconnection];
}

- (BOOL)isConnected {

    return [PNBitwiseHelper is:self.state strictly:YES containsBit:PNConnectionConnected] && ![self isReconnecting];
}

- (BOOL)isDisconnected {

    return ([PNBitwiseHelper is:self.state strictly:YES containsBit:PNConnectionDisconnected] ||
            [PNBitwiseHelper is:self.state containsBit:PNConnectionSuspended]) &&
            ![self isConnecting];
}

- (BOOL)isDisconnecting {

    // If at least one of the streams is disconnecting now treat it all as true
    return [PNBitwiseHelper is:self.state containsBit:PNConnectionDisconnecting];
}


#pragma mark - Error identification

- (BOOL)isConnectionIssuesError:(CFErrorRef)error {

    BOOL isConnectionIssue = NO;

    NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);
    if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainPOSIX]) {

        switch (CFErrorGetCode(error)) {

            case ENETDOWN:      // Network is down (maybe even no connection on interface level)

            // Error cases which may occurs during socket lifecycle, when gateway uplink may go down and additional
            // network check should be performed
            case ENETUNREACH:   // Remote host can't be reached
            case EHOSTDOWN:     // Remote host is down
            case EHOSTUNREACH:  // Host can't be reached, because there is no route to it
            case ECONNREFUSED:  // Remote host doesn't want to accept connection

                isConnectionIssue = YES;
                break;
            default:
                break;
        }
    }
    else if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainCFNetwork]) {

        switch (CFErrorGetCode(error)) {

            case kCFHostErrorHostNotFound:

                isConnectionIssue = YES;
                break;
            default:
                break;
        }
    }


    return isConnectionIssue;
}

- (BOOL)isConnectionUplinkError:(CFErrorRef)error {

    BOOL isConnectionUplinkError = NO;

    NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);
    if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainPOSIX]) {

        switch (CFErrorGetCode(error)) {

            case ENETUNREACH:   // Remote host can't be reached
            case EHOSTDOWN:     // Remote host is down
            case EHOSTUNREACH:  // Host can't be reached, because there is no route to it
            case ECONNREFUSED:  // Remote host doesn't want to accept connection

                isConnectionUplinkError = YES;
                break;
            default:
                break;
        }
    }


    return isConnectionUplinkError;
}

- (BOOL)isSecurityTransportError:(CFErrorRef)error {
    
    BOOL isSecurityTransportError = NO;

    CFIndex errorCode = CFErrorGetCode(error);
    NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);

    if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainOSStatus]) {
#if __IPHONE_OS_VERSION_MIN_REQUIRED
        isSecurityTransportError = (errSSLUnexpectedRecord <= errorCode) && (errorCode <= errSSLProtocol);
#else
        isSecurityTransportError = (errSSLLast <= errorCode) && (errorCode <= errSSLProtocol);
#endif
    }
    else if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainCFNetwork]) {
        
        isSecurityTransportError = (kCFURLErrorCannotLoadFromNetwork <= errorCode) &&
                                   (errorCode <= kCFURLErrorSecureConnectionFailed);
    }
    
    
    return isSecurityTransportError;
}

- (BOOL)isInternalSecurityTransportError:(CFErrorRef)error {

    CFIndex code = CFErrorGetCode(error);
    
    return (code == errSSLInternal) || (code == errSSLClosedAbort);
}

- (BOOL)isTemporaryError:(CFErrorRef)error {
    
    BOOL isTemporaryError = NO;
    
    CFIndex errorCode = CFErrorGetCode(error);
    NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);
    
    if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainPOSIX]) {
        
        switch (errorCode) {
            case ETIMEDOUT:     // There is no activity on socket for some time
            case ENETRESET:     // Remote host crashed w/o sending 'close packet'
            case ECONNABORTED:  // Connection was aborted locally (by system or device)

            // Special cases when connection state was changed by remote server
            case ECONNRESET:    // Remote host sent 'close packet'

            case ENOBUFS:       // No space where data for sockets can be stored
            case ENOTCONN:      // Socket not connected or was disconnected

            case ESHUTDOWN:     // Socket was closed before new write attempt has been done
            case ENOENT:        // Rare error when system probably can't prepare sockets for further operation
            case EPIPE:         // Remote host went down or socket configuration not completed
            case EAGAIN:        // Requested resource not available
            case EISCONN:       // Socket already connected

                isTemporaryError = YES;
                break;
            default:
                break;
        }
    }
    else if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainCFNetwork]) {

        isTemporaryError = (kCFNetServiceErrorDNSServiceFailure <= errorCode) && (errorCode <= kCFNetServiceErrorUnknown);
        if (!isTemporaryError) {

            isTemporaryError = errorCode == kCFHostErrorUnknown || errorCode == kCFErrorHTTPConnectionLost;
        }
    }
    
    
    return isTemporaryError;
}

- (BOOL)isServerError:(CFErrorRef)error {
    
    BOOL isServerError = NO;
    
    CFIndex errorCode = CFErrorGetCode(error);
    NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);
    
    if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainPOSIX]) {
        
        switch (errorCode) {
            
            case ECONNRESET:    // Remote host sent 'close packet'
                
                isServerError = YES;
                break;
            default:
                break;
        }
    }
    
    
    return isServerError;
}


#pragma mark - Connection lifecycle management methods

- (BOOL)prepareStreams {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@] PREPARE READ/WRITE STREAMS (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];

    BOOL streamsPrepared = YES;

    // Check whether stream was prepared and configured before
    if ([PNBitwiseHelper is:self.state strictly:YES containsBit:PNConnectionConfigured]) {

        NSString *state = @"";
        if ([self isConnecting]) {

            state = @"CONNECTING...";

        }
        else if ([self isConnected]) {

            state = @"CONNECTED.";
        }
        if ([self isResuming]) {

            state = @"RESUMING...";
        }
        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] STREAMS ALREADY CONFIGURATED%@ (STATE: %lu)",
                    self.name ? self.name : self, [state length] ? [NSString stringWithFormat:@" AND %@", state] : @".",
                    self.state];
        }];
    }
    else {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] CONFIGURATION STARTED (STATE: %lu)",
                    (self.name ? self.name : self), self.state];
        }];

        // Make sure that streams will be unable to operate (protection in case of state has been interrupted in some
        // way)
        [self destroyStreams];
        
        [PNBitwiseHelper removeFrom:&_state bit:PNConnectionDisconnecting];
        [PNBitwiseHelper addTo:&_state bit:PNConnectionDisconnected];


        // Define connection port which should be used by connection for further usage (depends on current connection
        // security policy)
        UInt32 targetPort = kPNOriginConnectionPort;
        if (self.configuration.shouldUseSecureConnection &&
            self.sslConfigurationLevel != PNConnectionSSLConfigurationInsecure) {

            targetPort = kPNOriginSSLConnectionPort;
        }

        // Retrieve connection proxy configuration
        [self retrieveSystemProxySettings];


        // Create stream pair on socket which is connected to specified remote host
        CFStreamCreatePairWithSocketToHost(CFAllocatorGetDefault(), (__bridge CFStringRef)(self.configuration.origin),
                                           targetPort, &_socketReadStream, &_socketWriteStream);

        [self configureReadStream:_socketReadStream];
        [self configureWriteStream:_socketWriteStream];

        // Check whether at least one of the streams was unable to complete configuration
        if (![PNBitwiseHelper is:self.state containsBit:PNConnectionConfigured]) {

            [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] CONFIGURATION FAILED (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];

            streamsPrepared = NO;

            [self destroyStreams];
            [self handleStreamSetupError];
        }
        else {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] CONFIGURATION COMPLETED (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];
        }
    }


    return streamsPrepared;
}

- (BOOL)connect {
    
    [PNBitwiseHelper addTo:&_state bit:PNByUserRequest];
    
    
    return [self connectByInternalRequest];
}

- (BOOL)connectByInternalRequest {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@] TRYING ESTABLISH CONNECTION... (BY USER REQUEST? %@)(STATE: %lu)",
                self.name ? self.name : self, [PNBitwiseHelper is:self.state containsBit:PNByUserRequest] ? @"YES" : @"NO",
                self.state];
    }];

    __block BOOL isStreamOpened = NO;

    // Check whether connection was requested by user or not
    if ([PNBitwiseHelper is:self.state containsBit:PNByUserRequest]) {

        BOOL shouldDestroyStreams = [self isConnecting] || [self isReconnecting] || [self isDisconnecting] || [self isResuming];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect,
         BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNByInternalRequest, PNByServerRequest, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR];

        if (shouldDestroyStreams) {
            
            [self destroyStreams];
        }
    }

    [PNBitwiseHelper addTo:&_state bit:PNConnectionPrepareToConnect];


    // Ask delegate whether connection can be opened or not (in case if there is no internet connection or client was
    // disconnected by user request)
    if ([self.delegate connectionCanConnect:self]) {

        // Check whether client has been properly configured or not
        if ([PNBitwiseHelper is:self.state strictly:YES containsBit:PNConnectionConfigured]) {

            [PNBitwiseHelper removeFrom:&_state bit:PNConnectionPrepareToConnect];

            BOOL isAbleToConnect = ![self isConnecting] && ![self isReconnecting] && ![self isConnected] &&
                                   ![self isDisconnecting] && ![self isResuming];

            if (isAbleToConnect) {

                // Mark that connection currently doesn't connected to the server
                [PNBitwiseHelper addTo:&_state bit:PNConnectionDisconnected];

                NSString *action = @"";

                // Check whether connection has been suspended before or not
                if ([PNBitwiseHelper is:self.state containsBit:PNConnectionSuspended]) {

                    // If connection is suspended, there is impossible that it may have any errors or ability to reconnect
                    [PNBitwiseHelper removeFrom:&_state bits:PNConnectionCleanReconnection, PNConnectionErrorCleanAll, PNConnectionSuspending,
                     BITS_LIST_TERMINATOR];
                    [PNBitwiseHelper addTo:&_state bit:PNConnectionResuming];

                    action = @"RESUMING";
                    
                }
                else if (![PNBitwiseHelper is:self.state strictly:YES containsBit:PNConnectionConnected]) {
                    
                    [PNBitwiseHelper removeFrom:&_state bits:PNConnectionSuspending, PNConnectionSuspended, PNConnectionResuming,
                     BITS_LIST_TERMINATOR];
                    action = [self shouldReconnect] ? @"RECONNECTING" : @"CONNECTING";
                }

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] %@... (STATE: %lu)",
                            self.name ? self.name : self, action, self.state];
                }];

                isStreamOpened = YES;

                [self startTimeoutTimer];
                [self suspendWakeUpTimer];

                [self openReadStream:self.socketReadStream];
                [self openWriteStream:self.socketWriteStream];
            }
            else {

                void(^forciblyConnectionBlock)(void) = ^{

                    [self stopTimeoutTimer];
                    [self suspendWakeUpTimer];

                    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] LOOKS LIKE STREAMS IN INTERMEDIATE "
                                "STATE AND OUT OF SYNC. FORCIBLY CONNECTING... (STATE: %lu)",
                                self.name ? self.name : self, self.state];
                    }];

                    BOOL isConnectingByUserRequest = [PNBitwiseHelper is:self.state containsBit:PNByUserRequest];
                    [PNBitwiseHelper removeFrom:&_state bit:PNByUserRequest];

                    if (isConnectingByUserRequest) {

                        // Mark that disconnection has been called because of internal request
                        [PNBitwiseHelper addTo:&_state bits:PNByInternalRequest, PNConnectionError, BITS_LIST_TERMINATOR];
                    }

                    // Forcibly close all connections
                    [self disconnectByInternalRequest];
                    isStreamOpened = isConnectingByUserRequest ? [self connect] : [self connectByInternalRequest];
                };

                if (![self isDisconnecting]) {

                    // Check whether tried to connect while already connected(-ing) or not. This condition take into
                    // account state of both streams at same time. If one of the stream has different state, this mean
                    // that connection probably in some wrong (messed) state.
                    BOOL isConnecting = [self isConnecting] || [self isReconnecting] || [self isConnected] || [self isResuming];

                    if (isConnecting) {

                        NSString *state = @"CONNECTING...";
                        if ([self isConnected]) {

                            state = @"CONNECTED.";
                        }

                        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                            return [NSString stringWithFormat:@"[CONNECTION::%@] ALREADY %@ (STATE: %lu)",
                                    self.name ? self.name : self, state, self.state];
                        }];
                    }
                    // Looks like tried to connect while was in some intermediate state (both streams in different
                    // states as for 'connected' or 'connecting'
                    else {

                        forciblyConnectionBlock();
                    }
                }
                else if ([self isDisconnecting]) {

                    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] TRIED TO CONNECT WHILE DISCONNETING"
                                ". WAIT FOR DISCONNECTION... (STATE: %lu)", self.name ? self.name : self, self.state];
                    }];

                    // Mark that client should try to connect back as soon as disconnection will be completed
                    [PNBitwiseHelper addTo:&_state bit:PNConnectionReconnectOnDisconnect];
                }
                else {

                    forciblyConnectionBlock();
                }
            }
        }
        // Looks like configuration not completed
        else {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] NOT CONFIGURED YET (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];

            // Try prepare connection's streams for future usage
            if ([self prepareStreams]) {

                isStreamOpened = [self connectByInternalRequest];
            }
        }
    }
    // Looks like connection can't be established at this moment. Launch wake up timer
    else {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] CONNECTION IS IMPOSSIBLE AT THIS MOMENT. "
                    "WAITING... (STATE: %lu)", self.name ? self.name : self, self.state];
        }];

        [PNBitwiseHelper addTo:&_state bit:PNConnectionWakeUpTimer];

        [self resumeWakeUpTimer];
    }


    return isStreamOpened;
}

- (BOOL)canRetryConnection {
    
    return self.connectionRetryCount < kPNMaximumConnectionRetryCount;
}

- (void)retryConnection {
    
    self.connectionRetryCount++;

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@] RETRY CONNECTION (%lu / %lu) (STATE: %lu)",
                self.name ? self.name : self, (unsigned long)self.connectionRetryCount, (unsigned long)kPNMaximumConnectionRetryCount, self.state];
    }];
    
    // Check whether reconnection was issued because of SSL error or not
    if (self.sslConfigurationLevel == PNConnectionSSLConfigurationInsecure &&
        [PNBitwiseHelper is:self.state strictly:YES containsBits:PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR]) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] RETRY CONNECTION BECAUSE OF INTERNAL SSL ERROR (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];
    }
    // Check whether reconnection was issued because of socket temporary issues or not
    else if ([PNBitwiseHelper is:self.state strictly:YES containsBits:PNByInternalRequest, PNConnectionSocket, BITS_LIST_TERMINATOR]) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] RETRY CONNECTION BECAUSE OF TEMPORARY ISSUES WITH SERVER "
                    "OR SOCKET (STATE: %lu)", self.name ? self.name : self, self.state];
        }];
    }
    
    [self reconnect];
}

- (void)reconnect {

    unsigned long oldStates = self.state;
    BOOL shouldReconnect = [self.delegate connectionShouldRestoreConnection:self];
    unsigned long newStates = self.state;

    BOOL stateChangedFromOutside = (oldStates != newStates && ![PNBitwiseHelper is:oldStates containsBit:PNByUserRequest] &&
                                    [PNBitwiseHelper is:newStates containsBit:PNByUserRequest]);

    if (!stateChangedFromOutside) {

        if (shouldReconnect) {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] TRYING TO RECONNECT... (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];
        }
        else {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] RECONNECT IS IMPOSSIBLE AT THIS MOMENT. WAITING. (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];
        }

        // Ask delegate whether connection should initiate connection to remote host or not
        if (shouldReconnect) {

            BOOL isWaitingForReconnection = [PNBitwiseHelper is:self.state containsBit:PNConnectionReconnect];
            BOOL isReconnectingBecauseOfError = [PNBitwiseHelper is:self.state containsBit:PNConnectionError];
            [PNBitwiseHelper removeFrom:&_state bits:PNConnectionCleanReconnection, PNConnectionError, BITS_LIST_TERMINATOR];

            // Marking that connection instance is reconnecting now and after last connection will be closed should
            // automatically renew connection
            [PNBitwiseHelper addTo:&_state bit:PNConnectionReconnect];
            [self destroyStreams];

            // Check whether 'reconnection' delayed request already has been issued or not
            if (!isWaitingForReconnection) {

                // Attempt to restore connection after small delay defined in 'static' section of this class
                __pn_desired_weak __typeof__ (self) weakSelf = self;
                NSTimeInterval delay = (NSTimeInterval) kPNConnectionRetryDelay;
                if (!isReconnectingBecauseOfError) {

                    delay = kPNConnectionRetryFastDelay;
                }
                dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC));
                dispatch_after(popTime, dispatch_get_main_queue(), ^{

                    if ([PNBitwiseHelper is:weakSelf.state containsBit:PNConnectionReconnect]) {

                        [self disconnectByInternalRequest];
                    }
                });
            }
        }
        else {

            [PNBitwiseHelper addTo:&_state bit:PNConnectionWakeUpTimer];

            [self resumeWakeUpTimer];
        }
    }
    else {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] RECONNECT CANCELED. CONNECTION STATE HAS BEEN CHANGED "
                    "FROM OUTSIDE. (STATE: %lu)", self.name ? self.name : self, self.state];
        }];

        [PNBitwiseHelper addTo:&_state bit:PNConnectionWakeUpTimer];

        [self resumeWakeUpTimer];
    }
}

- (void)disconnect {
    
    [PNBitwiseHelper addTo:&_state bit:PNByUserRequest];
    self.connectionRetryCount = 0;
    
    [self disconnectByInternalRequest];
}

- (void)disconnectOnInternalRequest {
    
    [PNBitwiseHelper removeFrom:&_state bits:PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR];
    [PNBitwiseHelper removeFrom:&_state bits:PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect, BITS_LIST_TERMINATOR];
    [PNBitwiseHelper removeFrom:&_state bits:PNByInternalRequest, PNByUserRequest, PNByServerRequest, BITS_LIST_TERMINATOR];
    [PNBitwiseHelper removeFrom:&_state bits:PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR];
    [PNBitwiseHelper removeFrom:&_state bits:PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR];


    [self disconnectByInternalRequest];
}

- (void)disconnectByInternalRequest {

    // Launch 'wake up' timer in case if disconnection was accident or some catch up logic failed because some tragic coincidence
    [self startWakeUpTimer];
    [self stopTimeoutTimer];

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@] TRYING DISCONNECT... (BY USER REQUEST? %@)(STATE: %lu)",
                self.name ? self.name : self, [PNBitwiseHelper is:self.state containsBit:PNByUserRequest] ? @"YES" : @"NO",
                self.state];
    }];
    
    [PNBitwiseHelper removeFrom:&_state bits:PNConnectionConnecting, PNConnectionPrepareToConnect, PNConnectionResuming, BITS_LIST_TERMINATOR];

    // Check whether it was requested to perform disconnection on user request or not
    if ([PNBitwiseHelper is:self.state containsBit:PNByUserRequest]) {
        
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNByInternalRequest, PNByServerRequest, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR];
    }

    // Clean up cached data
    [self unscheduleRequestsExecution];
    self.proxySettings = nil;

    [self disconnectReadStream:_socketReadStream];
    [self disconnectWriteStream:_socketWriteStream];
}

- (void)destroyStreams {

    BOOL isAnyOfStreamsStillValid = _socketReadStream != NULL || _socketWriteStream != NULL;
    if (isAnyOfStreamsStillValid) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] DESTROYING STREAMS... (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];
    }

    // Clean up cached data
    [self unscheduleRequestsExecution];
    self.proxySettings = nil;

    BOOL isConfiguring = [PNBitwiseHelper is:self.state containsBit:PNConnectionConfiguring];
    BOOL isReadStreamErrorSet = [PNBitwiseHelper is:self.state containsBit:PNReadStreamError];
    BOOL isWriteStreamErrorSet = [PNBitwiseHelper is:self.state containsBit:PNWriteStreamError];

    [self destroyReadStream:_socketReadStream];
    [self destroyWriteStream:_socketWriteStream];
    
    [PNBitwiseHelper removeFrom:&_state bits:PNReadStreamCleanAll, PNWriteStreamCleanAll, BITS_LIST_TERMINATOR];
    [PNBitwiseHelper addTo:&_state bit:PNConnectionDisconnected];

    if (isConfiguring) {

        [PNBitwiseHelper addTo:&_state bit:PNConnectionConfiguring];
    }

    if (isReadStreamErrorSet || isWriteStreamErrorSet) {

        [PNBitwiseHelper addTo:&_state bit:PNConnectionError];
    }

    if (isAnyOfStreamsStillValid) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] READ AND WRITE STREAMS DESTROYED (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];
    }
}

- (void)suspend {

    // Check whether connection established to the remote host or not
    if ([self isConnected]) {

        // Check whether connection can be suspended or not
        if (![self isSuspending] && ![self isSuspended]) {
            
            [PNBitwiseHelper removeFrom:&_state bits:PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR];
            [PNBitwiseHelper removeFrom:&_state bits:PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect, BITS_LIST_TERMINATOR];
            [PNBitwiseHelper removeFrom:&_state bits:PNByInternalRequest, PNByServerRequest, BITS_LIST_TERMINATOR];
            [PNBitwiseHelper removeFrom:&_state bits:PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR];
            [PNBitwiseHelper removeFrom:&_state bits:PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR];

            [PNBitwiseHelper addTo:&_state bit:PNConnectionSuspending];
            [self disconnectByInternalRequest];
        }
        // Looks like connection already suspended
        else if ([self isSuspended]){

            [self.delegate connectionDidSuspend:self];
        }
    }
    else {

        [self disconnectOnInternalRequest];
        [PNBitwiseHelper addTo:&_state bits:PNConnectionDisconnected, PNConnectionSuspended, BITS_LIST_TERMINATOR];

        [self.delegate connectionDidSuspend:self];
    }

    [self suspendWakeUpTimer];
    [self stopTimeoutTimer];
}

- (BOOL)isSuspending {

    return [PNBitwiseHelper is:self.state containsBit:PNConnectionSuspending];
}

- (BOOL)isSuspended {

    return [PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionDisconnected, PNConnectionSuspended, BITS_LIST_TERMINATOR];
}

- (void)resume {

    // Check whether connection suspended at this moment or not
    if (![self isConnected] && [self isSuspended] && ![self isResuming]) {

        // In case if because of some reasons connection can't be established we should launch 'wake up' timer to
        // help fix connection state when it will be possible
        if(![self connectByInternalRequest]) {

            [PNBitwiseHelper addTo:&_state bit:PNConnectionWakeUpTimer];

            [self resumeWakeUpTimer];
        }
    }
    else if ([self isConnected]) {

        [self.delegate connectionDidResume:self];
    }
}

- (BOOL)isResuming {

    return [PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionConnecting, PNConnectionResuming, BITS_LIST_TERMINATOR];
}


#pragma mark - Read stream lifecycle management methods

- (void)configureReadStream:(CFReadStreamRef)readStream {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@::READ] CONFIGURING... (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];

    [PNBitwiseHelper removeFrom:&_state bit:PNReadStreamCleanConfiguration];
    [PNBitwiseHelper addTo:&_state bit:PNReadStreamConfiguring];

    CFOptionFlags options = (kCFStreamEventOpenCompleted | kCFStreamEventHasBytesAvailable |
                             kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered);
    CFStreamClientContext client = [self streamClientContext];

    // Configuring connection channel instance as client for read stream with described set of handling events
    BOOL isStreamReady = CFReadStreamSetClient(readStream, options, readStreamCallback, &client);
    if (isStreamReady) {

        isStreamReady = CFReadStreamSetProperty(readStream, kCFStreamPropertyShouldCloseNativeSocket, kCFBooleanTrue);
    }

    if (self.streamSecuritySettings != NULL && isStreamReady) {

        // Configuring stream to establish SSL connection
        isStreamReady = CFReadStreamSetProperty(readStream,
                                                (__bridge CFStringRef)NSStreamSocketSecurityLevelKey,
                                                (__bridge CFStringRef)NSStreamSocketSecurityLevelSSLv3);

        if (isStreamReady) {

            // Specify connection security options
            isStreamReady = CFReadStreamSetProperty(readStream, kCFStreamPropertySSLSettings, self.streamSecuritySettings);
        }
    }


    if (isStreamReady) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@::READ] CONFIGURATION COMPLETED (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];

        [PNBitwiseHelper removeFrom:&_state bit:PNReadStreamConfiguring];
        [PNBitwiseHelper addTo:&_state bit:PNReadStreamConfigured];

        // Schedule read stream on current run-loop
        CFReadStreamScheduleWithRunLoop(readStream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);
    }
    else {

        [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@::READ] CONFIGURATION FAILED (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];

        [PNBitwiseHelper addTo:&_state bit:PNReadStreamError];
    }
}

- (void)openReadStream:(CFReadStreamRef)readStream {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@::READ] SCHEDULING OPENING... (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];

    [PNBitwiseHelper removeFrom:&_state bit:PNReadStreamCleanConnection];
    [PNBitwiseHelper addTo:&_state bit:PNReadStreamConnecting];

    if (!CFReadStreamOpen(readStream)) {

        CFErrorRef error = CFReadStreamCopyError(readStream);
        if (error && CFErrorGetCode(error) != 0) {

            [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@::READ] FAILED TO OPEN (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];

            [PNBitwiseHelper addTo:&_state bit:PNReadStreamError];
            [self handleStreamError:error];
        }
        else {

            CFRunLoopRun();
        }
        
        [PNHelper releaseCFObject:&error];
    }
    else {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@::READ] OPEN IS SCHEDULED (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];
    }
}

- (void)disconnectReadStream:(CFReadStreamRef)readStream {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@::READ] DISCONNECTING... (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];
    
    [PNBitwiseHelper removeFrom:&_state bits:PNReadStreamConnecting, PNReadStreamCleanDisconnection, BITS_LIST_TERMINATOR];
    [PNBitwiseHelper addTo:&_state bit:PNReadStreamDisconnecting];

    // Check whether there is some data received from server and try to parse it
    if ([_retrievedData length] > 0 || [_temporaryRetrievedData length] > 0) {

        [self processResponse];
    }

    // Destroying input buffer
    _retrievedData = nil;
    _temporaryRetrievedData = nil;

    BOOL streamHasError = [PNBitwiseHelper is:self.state containsBit:PNReadStreamError];
    [self destroyReadStream:readStream];

    if (streamHasError) {

        [PNBitwiseHelper addTo:&_state bit:PNReadStreamError];
    }
    [self handleStreamClose];
}

- (void)destroyReadStream:(CFReadStreamRef)readStream {

    BOOL isStreamExists = readStream != NULL;
    if (isStreamExists) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@::READ] DESTROYING... (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];
    }

    if (isStreamExists) {

        CFReadStreamSetClient(readStream, kCFStreamEventNone, NULL, NULL);
        CFReadStreamClose(readStream);
        [PNHelper releaseCFObject:&readStream];
        self.socketReadStream = NULL;
    }

    [PNBitwiseHelper removeFrom:&_state bit:PNReadStreamCleanConfiguration];

    if (isStreamExists) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@::READ] DESTROYED (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];
    }
}


#pragma mark - Read stream lifecycle data processing methods

- (void)readStreamContent {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@::READ] READING ARRIVED DATA... (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];

    // Check whether data available right now or not (this is non-blocking request)
    if (CFReadStreamHasBytesAvailable(self.socketReadStream)) {

        // Read raw data from stream
        UInt8 buffer[kPNStreamBufferSize];
        CFIndex readedBytesCount = CFReadStreamRead(self.socketReadStream, buffer, kPNStreamBufferSize);

        // Checking whether client was able to read out some data from stream or not
        if (readedBytesCount > 0) {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@::READ] READED %lld BYTES (STATE: %lu)",
                        self.name ? self.name : self, (long long)readedBytesCount, self.state];
            }];

            if ([PNLogger isDumpingHTTPResponse] || [PNLogger isLoggerEnabled]) {

                NSData *tempData = [NSData dataWithBytes:buffer length:(NSUInteger)readedBytesCount];

                [PNLogger storeHTTPPacketData:^NSData * {

                    return tempData;
                }];

                [PNLogger logFrom:self forLevel:PNLogConnectionLayerHTTPLoggingLevel message:^NSString * {

                    NSString *responseString = [[NSString alloc] initWithData:tempData encoding:NSUTF8StringEncoding];
                    if (!responseString) {

                        responseString = [[NSString alloc] initWithData:tempData encoding:NSASCIIStringEncoding];
                    }
                    if (!responseString) {

                        responseString = @"Can't striongify response. Try check response dump on file system (if enabled)";
                    }

                    return [NSString stringWithFormat:@"[CONNECTION::%@::READ] RESPONSE: %@",
                            self.name ? self.name : self, responseString];
                }];
            }

            // Check whether working on data deserialization or not
            if (self.deserializer.isDeserializing) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@::READ] DESERIALIZED IS BUSY. WRITTING INTO TEMPORARY"
                            " STORAGE (STATE: %lu)", self.name ? self.name : self, self.state];
                }];

                // Temporary store data in object
                [self.temporaryRetrievedData appendBytes:buffer length:(NSUInteger)readedBytesCount];
            }
            else {

                // Store fetched data
                [self.retrievedData appendBytes:buffer length:(NSUInteger)readedBytesCount];
                [self processResponse];
            }
        }
        // Looks like there is no data or error occurred while tried to read out stream content
        else if (readedBytesCount < 0) {

            [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@::READ] READ ERROR (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];

            CFErrorRef error = CFReadStreamCopyError(self.socketReadStream);
            [PNBitwiseHelper addTo:&_state bit:PNReadStreamError];
            [self handleStreamError:error];
            
            [PNHelper releaseCFObject:&error];
        }
    }
}

- (void)processResponse {

    // Retrieve response objects from server response
    NSArray *responses = [self.deserializer parseResponseData:self.retrievedData];

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@::READ] {%lu} RESPONSE MESSAGES PROCESSED (STATE: %lu)",
                self.name ? self.name : self, (unsigned long)[responses count], self.state];
    }];

    if ([responses count] > 0) {

        [responses enumerateObjectsUsingBlock:^(id response, NSUInteger responseIdx, BOOL *responseEnumeratorStop) {

            // Check whether server reported that connection will be closed after this portion of data
            if (![PNBitwiseHelper is:self.state containsBit:PNByServerRequest] && [(id<PNResponseProtocol>)response isLastResponseOnConnection]) {
                
                [PNBitwiseHelper addTo:&_state bits:PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR];

                // Inform delegate that connection will be closed soon by server request
                [self.delegate connection:self willDisconnectByServerRequestFromHost:self.configuration.origin];
            }

            // Notify delegate about new event arrival
            [self.delegate connection:self didReceiveResponse:response];
        }];
    }


    // Check whether connection stored some response in temporary storage or not
    if ([_temporaryRetrievedData length] > 0) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@::READ] THERE IS %lu BYTES IN TEMPORARY BUFFER. PROCESS... (STATE: %lu)",
                    self.name ? self.name : self, (unsigned long)[_temporaryRetrievedData length], self.state];
        }];

        [self.retrievedData appendData:_temporaryRetrievedData];
        _temporaryRetrievedData = nil;

        // Try to process retrieved data once more (maybe some full response arrived from remote server)
        [self processResponse];
    }
    else {

        // Check whether client is still connected and there is request from server side to close connection.
        // Connection will be restored after full disconnection
        if ([self isConnected] && ![self isReconnecting] && ![self isDisconnecting] &&
            [PNBitwiseHelper is:self.state containsBit:PNByServerRequest]) {

            [self disconnectByInternalRequest];
        }
    }
}


#pragma mark - Write stream lifecycle management methods


- (void)configureWriteStream:(CFWriteStreamRef)writeStream {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] CONFIGURING... (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];

    [PNBitwiseHelper removeFrom:&_state bit:PNWriteStreamCleanConfiguration];
    [PNBitwiseHelper addTo:&_state bit:PNWriteStreamConfiguring];

    CFOptionFlags options = (kCFStreamEventOpenCompleted | kCFStreamEventCanAcceptBytes |
                             kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered);
    CFStreamClientContext client = [self streamClientContext];

    // Configuring connection channel instance as client for write stream with described set of handling events
    BOOL isStreamReady = CFWriteStreamSetClient(writeStream, options, writeStreamCallback, &client);
    if (isStreamReady) {
        
        isStreamReady = CFWriteStreamSetProperty(writeStream, kCFStreamPropertyShouldCloseNativeSocket, kCFBooleanTrue);
    }


    if (isStreamReady) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] CONFIGURATION COMPLETED (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];

        [PNBitwiseHelper removeFrom:&_state bit:PNWriteStreamConfiguring];
        [PNBitwiseHelper addTo:&_state bit:PNWriteStreamConfigured];

        // Schedule write stream on current run-loop
        CFWriteStreamScheduleWithRunLoop(writeStream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);
    }
    else {

        [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] CONFIGURATION FAILED (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];

        [PNBitwiseHelper addTo:&_state bit:PNWriteStreamError];
    }
}

- (void)openWriteStream:(CFWriteStreamRef)writeStream {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] SCHEDULING OPENING... (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];

    [PNBitwiseHelper removeFrom:&_state bit:PNWriteStreamCleanConnection];
    [PNBitwiseHelper addTo:&_state bit:PNWriteStreamConnecting];

    if (!CFWriteStreamOpen(writeStream)) {

        CFErrorRef error = CFWriteStreamCopyError(writeStream);
        if (error && CFErrorGetCode(error) != 0) {

            [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] FAILED TO OPEN (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];

            [PNBitwiseHelper addTo:&_state bit:PNWriteStreamError];
            [self handleStreamError:error];
        }
        else {

            CFRunLoopRun();
        }
        
        [PNHelper releaseCFObject:&error];
    }
    else {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] OPEN IS SCHEDULED (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];
    }
}

- (void)disconnectWriteStream:(CFWriteStreamRef)writeStream {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] DISCONNECTING... (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];
    
    [PNBitwiseHelper removeFrom:&_state bits:PNWriteStreamConnecting, PNWriteStreamCleanDisconnection, BITS_LIST_TERMINATOR];
    [PNBitwiseHelper addTo:&_state bit:PNWriteStreamDisconnecting];
    self.writeStreamCanHandleData = NO;

    // Handle canceled request (if there was such)
    [self handleRequestSendingCancelation];

    BOOL streamHasError = [PNBitwiseHelper is:self.state containsBit:PNWriteStreamError];
    [self destroyWriteStream:writeStream];

    if (streamHasError) {

        [PNBitwiseHelper addTo:&_state bit:PNWriteStreamError];
    }
    [self handleStreamClose];
}

- (void)destroyWriteStream:(CFWriteStreamRef)writeStream {

    BOOL isStreamExists = writeStream != NULL;
    if (isStreamExists) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] DESTROYING... (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];
    }

    if (isStreamExists) {

        CFWriteStreamSetClient(writeStream, kCFStreamEventNone, NULL, NULL);
        CFWriteStreamClose(writeStream);
        [PNHelper releaseCFObject:&writeStream];
        self.socketWriteStream = NULL;
    }

    [PNBitwiseHelper removeFrom:&_state bit:PNWriteStreamCleanConfiguration];

    if (isStreamExists) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] DESTROYED (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];
    }
}


#pragma mark - Write stream buffer management methods

- (void)prepareNextRequestPacket {

    // Ensure that connection is able to send next portion of data which will be prepared
    
    BOOL shouldPrepareData = [self isConnected] && ![self isReconnecting] && ![self isDisconnecting] &&
                             ![PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionDisconnect,
                               PNByServerRequest, BITS_LIST_TERMINATOR] && ![self isResuming];

    if (shouldPrepareData) {

        // Check whether data source can provide some data right after connection is established or not
        if ([self.dataSource hasDataForConnection:self]) {

            NSString *requestIdentifier = [self.dataSource nextRequestIdentifierForConnection:self];
            self.writeBuffer = [self.dataSource connection:self requestDataForIdentifier:requestIdentifier];
        }
    }
}

- (void)writeBufferContent {

    BOOL(^writeStreamIsAbleToSend)(void) = ^{

        return (BOOL)([self isConnected] && ![self isReconnecting] && ![self isDisconnecting] &&
                      ![PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR] &&
                      self.isWriteStreamCanHandleData && ![self isResuming]);
    };

    // Check whether there is connection which can be used to write data
    if (writeStreamIsAbleToSend()) {

        if (self.writeBuffer != nil) {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] WRITE BUFFER CONTENT (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];

            [PNBitwiseHelper removeFrom:&_state bit:PNWriteStreamError];

            if (self.writeBuffer.length > 0) {

                [PNBitwiseHelper removeFrom:&_state bit:PNWriteStreamError];
                [PNBitwiseHelper addTo:&_state bit:PNSendingData];

                // Check whether connection can pull some data
                // from write buffer or not
                BOOL isWriteBufferIsEmpty = ![self.writeBuffer hasData];
                if (!isWriteBufferIsEmpty) {

                    if (self.isWriteStreamCanHandleData) {

                        // Check whether we just started request processing or not
                        if (self.writeBuffer.offset == 0) {

                            // Mark that buffer content sending was initiated
                            self.writeBuffer.sendingBytes = YES;

                            // Notify data source that we started request processing
                            [self.dataSource connection:self processingRequestWithIdentifier:self.writeBuffer.requestIdentifier];
                        }

                        if (writeStreamIsAbleToSend() && self.writeBuffer != nil) {
                            
                            // Try write data into write stream
                            CFIndex bytesWritten = CFWriteStreamWrite(self.socketWriteStream, [self.writeBuffer buffer],
                                                                      [self.writeBuffer bufferLength]);

                            // Check whether error occurred while tried to process request
                            if (bytesWritten < 0) {

                                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                                    return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] WRITE ERROR (STATE: %lu)",
                                            self.name ? self.name : self, self.state];
                                }];

                                // Mark that buffer content is not processed at this moment
                                self.writeBuffer.sendingBytes = NO;
                                self.writeStreamCanHandleData = NO;

                                // Retrieve error which occurred while tried to write buffer into socket
                                CFErrorRef writeError = CFWriteStreamCopyError(self.socketWriteStream);
                                [PNBitwiseHelper addTo:&_state bit:PNWriteStreamError];

                                [self handleRequestProcessingError:writeError];
                                
                                [PNHelper releaseCFObject:&writeError];
                                isWriteBufferIsEmpty = YES;
                            }
                            // Check whether socket was able to transfer whole write buffer at once or not
                            else if (bytesWritten == self.writeBuffer.length) {

                                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                                    return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] WRITTEN WHOLE REQUEST BODY"
                                            " (%lld/%lld BYTES)(STATE: %lu)", self.name ? self.name : self,
                                            (long long)bytesWritten, (long long)self.writeBuffer.length, self.state];
                                }];

                                // Mark that buffer content is not processed at this moment
                                self.writeBuffer.sendingBytes = NO;

                                // Set readout offset to buffer content length (there is no more data to send)
                                self.writeBuffer.offset = self.writeBuffer.length;

                                isWriteBufferIsEmpty = YES;
                            }
                            else {

                                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                                    return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] WRITTEN PART OF REQUEST BODY"
                                            " (%lld/%lld BYTES)(STATE: %lu)", self.name ? self.name : self,
                                            (long long)(self.writeBuffer.offset + bytesWritten), (long long)self.writeBuffer.length,
                                            self.state];
                                }];

                                self.writeStreamCanHandleData = NO;

                                // Increase buffer readout offset
                                self.writeBuffer.offset = (self.writeBuffer.offset + bytesWritten);
                                if (self.writeBuffer.offset == self.writeBuffer.length) {

                                    self.writeStreamCanHandleData = YES;
                                    isWriteBufferIsEmpty = YES;
                                }
                            }
                        }
                        else {

                            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                                return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] WRITE CANCELED (STATE: %lu)",
                                        self.name ? self.name : self, self.state];
                            }];
                        }
                    }
                }


                if (isWriteBufferIsEmpty) {

                    [PNBitwiseHelper removeFrom:&_state bit:PNSendingData];

                    // Retrieving reference on request's identifier who's body has been sent
                    NSString *identifier = self.writeBuffer.requestIdentifier;
                    self.writeBuffer = nil;

                    [self.dataSource connection:self didSendRequestWithIdentifier:identifier];


                    // Check whether should try to send next request or not
                    if ([PNBitwiseHelper is:self.state containsBit:PNConnectionProcessingRequests]) {

                        if (writeStreamIsAbleToSend()) {

                            [self scheduleNextRequestExecution];
                        }
                        else if ([PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR]) {

                            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                                return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] CAN'T PROCESS NEXT REQUEST "
                                        "BECAUSE CONNECTION WILL BE CLOSED SOON (STATE: %lu)", self.name ? self.name : self,
                                        self.state];
                            }];
                        }
                    }
                }
            }
            // Looks like because of some reasons there is no new data
            else {

                if ([PNBitwiseHelper is:self.state containsBit:PNConnectionProcessingRequests]) {

                    if (writeStreamIsAbleToSend()) {

                        [self scheduleNextRequestExecution];
                    }
                    else if([PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR]) {

                        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                            return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] CAN'T PROCESS NEXT REQUEST "
                                    "BECAUSE CONNECTION WILL BE CLOSED SOON (STATE: %lu)", self.name ? self.name : self,
                                    self.state];
                        }];
                    }
                }
            }
        }
        else {

            [self scheduleNextRequestExecution];
        }
    }
    else if ([PNBitwiseHelper is:self.state strictly:YES containsBit:PNConnectionConnected]) {

        if ([PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR]) {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] CAN'T PROCESS NEXT REQUEST BECAUSE CONNECTION"
                        " WILL BE CLOSED SOON (STATE: %lu)", self.name ? self.name : self, self.state];
            }];
        }
        else {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@::WRITE] NOTHING TO WRITE (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];
        }
    }
}


#pragma mark - Handler methods

- (void)handleStreamConnection {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@] HANDLE STREAM CONNECTION OPENED (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];

    // Ensure that both read and write streams are connected before notify
    // delegate about successful connection
    if ([PNBitwiseHelper is:self.state strictly:YES containsBit:PNConnectionConnecting] &&
        [PNBitwiseHelper is:self.state strictly:YES containsBit:PNConnectionConnected]) {

        BOOL retriedConnection = self.connectionRetryCount != 0;

        // Resetting some cached data
        self.configurationRetryCount = 0;
        self.connectionRetryCount = 0;

        // Terminate wake up timer
        [self stopWakeUpTimer];

        
        BOOL isRestoredAfterServerClosed = [PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionDisconnect,
                                            PNByServerRequest, BITS_LIST_TERMINATOR];
        BOOL isConnectionReset = [PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionError,
                                  PNByInternalRequest, BITS_LIST_TERMINATOR];
        BOOL isReconnectedByWakeUpTimer = [PNBitwiseHelper is:self.state strictly:YES containsBits:PNByInternalRequest,
                                           PNConnectionWakeUpTimer, BITS_LIST_TERMINATOR];
        BOOL isReconnectedBySSL = [PNBitwiseHelper is:self.state strictly:YES containsBits:PNByInternalRequest,
                                   PNConnectionSSL, BITS_LIST_TERMINATOR];
        BOOL isReconnectedBySocket = [PNBitwiseHelper is:self.state strictly:YES containsBits:PNByInternalRequest,
                                      PNConnectionSocket, BITS_LIST_TERMINATOR];
        
        BOOL connectedAfterError = [PNBitwiseHelper is:self.state containsBit:PNConnectionError];
        BOOL isByUserRequest = [PNBitwiseHelper is:self.state containsBit:PNByUserRequest];
        BOOL isReconnecting = [self isReconnecting];
        BOOL isResuming = [self isResuming];
        
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNByInternalRequest, PNByUserRequest, PNByServerRequest, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR];

        if (retriedConnection) {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] CONNECTED ON RETRY (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];
        }

        // Check whether connection has been established as result of user calling '-connect' method or not
        if (isByUserRequest) {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] CONNECTED (BY USER REQUEST? %@)(STATE: %lu)",
                        self.name ? self.name : self, isByUserRequest ? @"YES" : @"NO", self.state];
            }];

            // Notify delegate that initial connection is established
            [self.delegate connection:self didConnectToHost:self.configuration.origin];
        }
        else {

            // Check whether connection is resuming after it was suspended or not
            if (isResuming) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] RESUMED (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];

                [self.delegate connectionDidResume:self];
            }
            // Check whether connection has been restored after server closed it (for example when server doesn't
            // support 'keep-alive' connection type
            else if (isRestoredAfterServerClosed) {

                // Inform delegate that connection finally recovered after it has been close by remote server
                [self.delegate  connection:self didRestoreAfterServerCloseConnectionToHost:self.configuration.origin];
            }
            // Check whether connection has been forcibly reset after found out that it is in wrong state
            else if (isConnectionReset) {

                // Inform delegate that connection has been completely reset and ready to work
                [self.delegate connectionDidReset:self];
            }
            // Check whether connection has been restored after some error occurred on streams
            else if (connectedAfterError) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] RECONNECTED AFTER ERROR (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];

                [self.delegate connection:self didReconnectToHostAfterError:self.configuration.origin];
            }
            // Check whether connection has been reconnected by request from 'wake up' timer/SSL/sockets
            else if (isReconnectedByWakeUpTimer || isReconnectedBySSL || isReconnectedBySocket) {

                NSString *eventSource = @"WAKE UP TIMER";
                if (isReconnectedBySSL) {

                    eventSource = @"SSL ERROR";
                }
                else if (isReconnectedBySocket) {

                    eventSource = @"NETWORK FAILURE OR SERVER TEMPORARY ISSUES";
                }

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] RECONNECTED BECAUSE OF %@ (STATE: %lu)",
                            self.name ? self.name : self, eventSource, self.state];
                }];

                [self.delegate connection:self didReconnectToHostAfterError:self.configuration.origin];
            }
            // Check whether connection has been reconnected by request or not
            else if (isReconnecting) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] RECONNECTED (BY USER REQUEST? %@)(STATE: %lu)",
                            self.name ? self.name : self, isByUserRequest ? @"YES" : @"NO", self.state];
                }];

                [self.delegate connection:self didReconnectToHost:self.configuration.origin];
            }
            else {

                [self.delegate connection:self didConnectToHost:self.configuration.origin];
            }
        }

        // Check whether channel should process requests from upper layers or not
        if ([PNBitwiseHelper is:self.state containsBit:PNConnectionProcessingRequests]) {

            [self scheduleNextRequestExecution];
        }
    }
}

- (void)handleStreamClose {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@] HANDLE STREAM CONNECTION CLOSED (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];

    // Ensure that both read and write streams reset before notify delegate about connection close event
    
    if ([PNBitwiseHelper is:self.state strictly:YES containsBit:PNConnectionDisconnecting] &&
        ![PNBitwiseHelper is:self.state strictly:YES containsBit:PNConnectionDisconnected]) {

        BOOL retriedConnection = self.connectionRetryCount != 0;

        // Resetting some cached data
        self.configurationRetryCount = 0;

        [self stopTimeoutTimer];

        BOOL isDisconnectedByServerRequest = [PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionDisconnect,
                                              PNByServerRequest, BITS_LIST_TERMINATOR];
        BOOL isDisconnectedOnReset = [PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionError, PNByInternalRequest,
                                      BITS_LIST_TERMINATOR];
        BOOL isDisconnectedByWakeUpTimer = [PNBitwiseHelper is:self.state strictly:YES containsBits:PNByInternalRequest,
                                            PNConnectionWakeUpTimer, BITS_LIST_TERMINATOR];
        BOOL isDisconnectedBySSL = [PNBitwiseHelper is:self.state strictly:YES containsBits:PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR];
        BOOL isDisconnectedBySocket = [PNBitwiseHelper is:self.state strictly:YES containsBits:PNByInternalRequest, PNConnectionSocket,
                                       BITS_LIST_TERMINATOR];
        BOOL isDisconnectedOnError = [PNBitwiseHelper is:self.state containsBit:PNConnectionError];
        BOOL isByUserRequest = [PNBitwiseHelper is:self.state containsBit:PNByUserRequest];
        BOOL shouldConnectOnDisconnect = [PNBitwiseHelper is:self.state containsBit:PNConnectionReconnectOnDisconnect];
        BOOL isReconnecting = [self shouldReconnect];
        BOOL isSuspending = [self isSuspending];
        
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNByInternalRequest, PNByUserRequest, PNByServerRequest, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper removeFrom:&_state bits:PNReadStreamCleanAll, PNWriteStreamCleanAll, BITS_LIST_TERMINATOR];
        [PNBitwiseHelper addTo:&_state bit:PNConnectionDisconnected];

        if (isDisconnectedOnError) {

            [PNBitwiseHelper addTo:&_state bit:PNConnectionError];
        }

        void(^reconnectOnErrorBlock)(void) = ^{

            // Attempt to restore connection after small delay defined in 'static' section of this class
            __pn_desired_weak __typeof__ (self) weakSelf = self;
            dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(kPNConnectionRetryDelay * NSEC_PER_SEC));
            dispatch_after(popTime, dispatch_get_main_queue(), ^{

                // Check whether connection is still in bad state before issue connection
                if ([PNBitwiseHelper is:weakSelf.state containsBit:PNConnectionError]) {

                    [PNLogger logConnectionInfoMessageFrom:weakSelf message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] RECONNECTING ON ERROR... (STATE: %lu)",
                                weakSelf.name ? weakSelf.name : weakSelf, weakSelf.state];
                    }];

                    [weakSelf resumeWakeUpTimer];
                    [self stopTimeoutTimer];

                    if (isByUserRequest) {

                        [PNLogger logConnectionInfoMessageFrom:weakSelf message:^NSString * {

                            return [NSString stringWithFormat:@"[CONNECTION::%@] CONNECT FROM THE NAME OF THE USER BECAUSE"
                                    " INITIAL CONNECT BEFORE ERROR HAS BEEN DONE BY HIM (STATE: %lu)",
                                    weakSelf.name ? weakSelf.name : weakSelf, weakSelf.state];
                        }];

                        [weakSelf connect];
                    }
                    else {

                        [weakSelf connectByInternalRequest];
                    }
                }
            });
        };

        if (retriedConnection) {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] DISCONNECTED ON RETRY (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];
        }

        if (shouldConnectOnDisconnect || isDisconnectedByServerRequest || isDisconnectedOnReset ||
            isDisconnectedByWakeUpTimer || isDisconnectedBySSL || isDisconnectedBySocket || isReconnecting ||
            retriedConnection) {

            unsigned long flagsToEnableBack = 0;

            // Check whether there was attempt to connect while was connection was in disconnection state
            if (shouldConnectOnDisconnect) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] CATCH UP PREVIOUS REQUEST TO CONNECT (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];
            }
            else if (isDisconnectedByServerRequest) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] EXPECTED DISCONNECTION. RECONNECTING... (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];
                
                [PNBitwiseHelper addTo:&flagsToEnableBack bits:PNByServerRequest, PNConnectionDisconnect, BITS_LIST_TERMINATOR];
                [PNBitwiseHelper addTo:&_state bit:flagsToEnableBack];

                // Notify delegate that connection has been terminated by server request
                [self.delegate connection:self didDisconnectByServerRequestFromHost:self.configuration.origin];
            }
            else if (isDisconnectedOnReset) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] DISCONNECTED ON CONNECTION RESET. RECONNECTING... (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];
                
                [PNBitwiseHelper addTo:&flagsToEnableBack bits:PNByInternalRequest, PNConnectionError, BITS_LIST_TERMINATOR];
            }
            else if (isDisconnectedByWakeUpTimer || isDisconnectedBySSL || isDisconnectedBySocket) {

                NSString *eventSource = @"WAKE UP TIMER";
                [PNBitwiseHelper addTo:&flagsToEnableBack bits:PNByInternalRequest, PNConnectionWakeUpTimer, BITS_LIST_TERMINATOR];

                if (isDisconnectedBySSL) {

                    [PNBitwiseHelper clear:&flagsToEnableBack];
                    [PNBitwiseHelper addTo:&flagsToEnableBack bits:PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR];

                    eventSource = @"SSL ERROR";
                }
                else if (isDisconnectedBySocket) {
                    
                    [PNBitwiseHelper clear:&flagsToEnableBack];
                    [PNBitwiseHelper addTo:&flagsToEnableBack bits:PNByInternalRequest, PNConnectionSocket, BITS_LIST_TERMINATOR];

                    eventSource = @"NETWORK FAILURE OR SERVER TEMPORARY ISSUES";
                }

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] RECONNECTING BECAUSE OF %@ (STATE: %lu)",
                            self.name ? self.name : self, eventSource, self.state];
                }];

                [PNBitwiseHelper addTo:&_state bit:flagsToEnableBack];

                // Notify delegate that connection will be restored because of reconnection request
                [self.delegate connection:self willReconnectToHostAfterError:self.configuration.origin];
            }
            else if (isReconnecting) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] RECONNECTING... (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];

                [PNBitwiseHelper addTo:&flagsToEnableBack bit:PNConnectionReconnection];

                // Notify delegate that connection will be restored because of reconnection request
                [self.delegate connection:self willReconnectToHost:self.configuration.origin];
            }
            else if (retriedConnection) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] RETRYING CONNECTION... (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];
            }

            [PNBitwiseHelper addTo:&_state bit:PNConnectionWakeUpTimer];
            [self resumeWakeUpTimer];
            if (isByUserRequest) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] CONNECT FROM THE NAME OF THE USER BECAUSE INITIAL"
                            " CONNECT BEFORE ERROR HAS BEEN DONE BY HIM (STATE: %lu)", self.name ? self.name : self,
                            self.state];
                }];

                [self connect];
            }
            else {

                [self connectByInternalRequest];
            }

            // Restore error state flags because of which connection should be restored back
            [PNBitwiseHelper addTo:&_state bit:flagsToEnableBack];
        }
        // Check whether connection has been closed by user request or not
        else if (isByUserRequest) {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] CONNECTION CLOSED BY USER REQUEST (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];

            if (!isDisconnectedOnError) {

                self.connectionRetryCount = 0;

                [PNBitwiseHelper addTo:&_state bit:PNConnectionWakeUpTimer];
                [self resumeWakeUpTimer];
                [self.delegate connection:self didDisconnectFromHost:self.configuration.origin];
            }
            else {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] DISCONNECTED BECAUSE OF ERROR (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];

                reconnectOnErrorBlock();
            }
        }
        // Disconnection has been done because of other reasons (configuration error / suspending)
        else {

            if (isSuspending) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] SUSPENDED (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];

                [PNBitwiseHelper addTo:&_state bit:PNConnectionSuspended];
                [self suspendWakeUpTimer];
                [self stopTimeoutTimer];

                [self.delegate connectionDidSuspend:self];
            }
            else {

                NSString *errorReason = @"";
                if (isDisconnectedOnError) {

                    errorReason = @"BECAUSE OF ERROR ";
                }

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] DISCONNECTED %@(STATE: %lu)",
                            self.name ? self.name : self, errorReason, self.state];
                }];

                // Check whether connection has been terminated because of error or not
                if (isDisconnectedOnError) {

                    reconnectOnErrorBlock();
                }
                else {

                    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] NOTIFY DELEGATE ABOUT DISCONNECTION (STATE: %lu)",
                                self.name ? self.name : self, self.state];
                    }];
                    self.connectionRetryCount = 0;

                    [self.delegate connection:self didDisconnectFromHost:self.configuration.origin];

                    [PNBitwiseHelper addTo:&_state bit:PNConnectionWakeUpTimer];
                    [self resumeWakeUpTimer];
                    [self stopTimeoutTimer];
                }
            }
        }
    }
}

- (void)handleReadStreamHasData {

    [self readStreamContent];
}

- (void)handleWriteStreamCanAcceptData {

    if (!self.isWriteStreamCanHandleData) {
        
        [self stopTimeoutTimer];
    }
    self.writeStreamCanHandleData = YES;

    if (![PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR]) {

        [self writeBufferContent];
    }
}

- (void)handleRequestSendingCancelation {

    // Check whether data sending layer is processing some request or not
    if ([PNBitwiseHelper is:self.state containsBit:PNSendingData] || self.writeBuffer != nil) {

        NSString *interruptedRequestIdentifier = self.writeBuffer.requestIdentifier;

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] UNSCHEDULE REQUEST SENDING (%@)(STATE: %lu)",
                    self.name ? self.name : self, interruptedRequestIdentifier, self.state];
        }];

        self.writeBuffer = nil;
        [PNBitwiseHelper removeFrom:&_state bit:PNSendingData];

        // Notify delegate about that request processing hasn't been completed
        [self.dataSource connection:self didCancelRequestWithIdentifier:interruptedRequestIdentifier];
    }
}

- (void)handleStreamTimeout {
    
    [PNBitwiseHelper removeFrom:&_state bits:PNConnectionCleanReconnection, PNByUserRequest, PNByServerRequest, PNByInternalRequest,
     PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR];
    [PNBitwiseHelper removeFrom:&_state bits:PNConnectionSuspending, PNConnectionSuspended, PNConnectionResuming, BITS_LIST_TERMINATOR];
    [PNBitwiseHelper addTo:&_state bit:PNConnectionDisconnected];

    [self reconnect];
}

- (void)handleTimeoutTimer:(NSTimer *)timer {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@] HANDLE 'TIMEOUT' TIMER EVENT (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];

    [self handleStreamTimeout];
}

- (void)handleWakeUpTimer {

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@] HANDLE 'WAKE UP' TIMER EVENT (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];


    // Check whether connection not connected
    if ((![self isConnected] && ![self isConnecting]) || [PNBitwiseHelper is:self.state containsBit:PNConnectionWakeUpTimer]) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] STILL IN BAD STATE... (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];


        unsigned long oldStates = self.state;
        BOOL shouldReconnect = [self.delegate connectionShouldRestoreConnection:self];
        unsigned long newStates = self.state;

        BOOL stateChangedFromOutside = oldStates != newStates && ![PNBitwiseHelper is:oldStates containsBit:PNByUserRequest] &&
                                       [PNBitwiseHelper is:newStates containsBit:PNByUserRequest];

        if (!stateChangedFromOutside) {

            // Ask delegate on whether connection should be restored or not
            if (shouldReconnect) {

                BOOL actionByUserRequest = [PNBitwiseHelper is:self.state containsBit:PNByUserRequest];

                // Mark that since state fixing has been called from 'wake up' timer handler method, all further actions
                // performed on internal code request
                [PNBitwiseHelper removeFrom:&_state bits:PNByUserRequest, PNByServerRequest, BITS_LIST_TERMINATOR];
                [PNBitwiseHelper addTo:&_state bits:PNByInternalRequest, PNConnectionWakeUpTimer, BITS_LIST_TERMINATOR];

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] HAVE A CHANCE TO FIX ITS STATE (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];

                // Check whether connection should be restored via '-reconnect' method or not
                if ([self shouldReconnect]) {

                    [self reconnect];
                }
                else if ([PNBitwiseHelper is:self.state containsBit:PNConnectionPrepareToConnect]) {

                    if (actionByUserRequest) {

                        [self connect];
                    }
                    else {

                        [self connectByInternalRequest];
                    }
                }
                else {
                    
                    [PNBitwiseHelper removeFrom:&_state bits:PNReadStreamCleanAll, PNWriteStreamCleanAll, PNConnectionReconnection,
                     BITS_LIST_TERMINATOR];
                    [self disconnectByInternalRequest];
                }
            }
            else {

                // Looks like connection can't be established, so there can be no 'connecting' state
                [PNBitwiseHelper removeFrom:&_state bits:PNConnectionConnecting, PNConnectionDisconnecting, BITS_LIST_TERMINATOR];
            }
        }
        else {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] WAKE UP EVENT CANCELED. CONNECTION STATE HAS BEEN CHANGED"
                        " FROM OUTSIDE. (STATE: %lu)", self.name ? self.name : self, self.state];
            }];
        }
    }
}

- (NSString *)stringifyStreamStatus:(CFStreamStatus)status {

    NSString *stringifiedStatus = @"NOTHING INTERESTING";

    switch (status) {
        case kCFStreamStatusNotOpen:

            stringifiedStatus = @"STREAM NOT OPENED";
            break;
        case kCFStreamStatusOpening:

            stringifiedStatus = @"STREAM IS OPENING";
            break;
        case kCFStreamStatusOpen:

            stringifiedStatus = @"STREAM IS OPENED";
            break;
        case kCFStreamStatusReading:

            stringifiedStatus = @"READING FROM STREAM";
            break;
        case kCFStreamStatusWriting:

            stringifiedStatus = @"WRITING INTO STREAM";
            break;
        case kCFStreamStatusAtEnd:

            stringifiedStatus = @"STREAM CAN'T READ/WRITE DATA";
            break;
        case kCFStreamStatusClosed:

            stringifiedStatus = @"STREAM CLOSED";
            break;
        case kCFStreamStatusError:

            stringifiedStatus = @"STREAM ERROR OCCURRED";
            break;
    }


    return stringifiedStatus;
}

- (void)handleStreamError:(CFErrorRef)error {

    [self handleStreamError:error shouldCloseConnection:NO];
}

- (void)handleStreamError:(CFErrorRef)error shouldCloseConnection:(BOOL)shouldCloseConnection {

    if (error && CFErrorGetCode(error) != 0) {

        NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);
        PNError *errorObject = [self processStreamError:error];

        [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] GOT ERROR: %@ (CFNetwork error code: %lld (Domain: %@);"
                    " connection should be close? %@)(STATE: %lu)", self.name ? self.name : self, errorObject,
                    (long long)CFErrorGetCode(error), errorDomain, shouldCloseConnection ? @"YES" : @"NO", self.state];
        }];

        // Check whether error is caused by SSL issues or not
        if ([self isSecurityTransportError:error]) {

            [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] SSL ERROR OCCURRED (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];

            if (![self isInternalSecurityTransportError:error]) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] IS SECURITY LEVEL REDUCTION ALLOWED? %@",
                            self.name ? self.name : self, self.configuration.shouldReduceSecurityLevelOnError ? @"YES" : @"NO"];
                }];

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] IS IT ALLOWED TO DISCARD SECURITY SETTINGS? %@",
                            self.name ? self.name : self, self.configuration.canIgnoreSecureConnectionRequirement ? @"YES" : @"NO"];
                }];

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] CURRENT SSL CONFIGURATION LEVEL: %d",
                            self.name ? self.name : self, self.sslConfigurationLevel];
                }];
                
                // Checking whether user allowed to decrease security options and we can do it
                if (self.configuration.shouldReduceSecurityLevelOnError &&
                    self.sslConfigurationLevel == PNConnectionSSLConfigurationStrict) {

                    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] REDUCING SSL REQUIREMENTS",
                                self.name ? self.name : self];
                    }];

                    shouldCloseConnection = NO;
                    
                    self.sslConfigurationLevel = PNConnectionSSLConfigurationBarelySecure;
                    [PNBitwiseHelper removeFrom:&_state bit:PNConnectionErrorCleanAll];
                    [PNBitwiseHelper addTo:&_state bits:PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR];

                    // Try to reconnect with new SSL security settings
                    [self reconnect];
                }
                // Check whether connection can fallback and use plain HTTP connection w/o SSL
                else if (self.configuration.canIgnoreSecureConnectionRequirement &&
                         self.sslConfigurationLevel == PNConnectionSSLConfigurationBarelySecure) {

                    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] DISCARD SSL", self.name ? self.name : self];
                    }];

                    shouldCloseConnection = NO;
                    
                    self.sslConfigurationLevel = PNConnectionSSLConfigurationInsecure;
                    [PNBitwiseHelper removeFrom:&_state bit:PNConnectionErrorCleanAll];
                    [PNBitwiseHelper addTo:&_state bits:PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR];
                    
                    // Try to reconnect with new SSL security settings
                    [self reconnect];
                }
            }
            else {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] INTERNAL SSL ERROR OCCURRED (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];

                shouldCloseConnection = NO;
                [PNBitwiseHelper removeFrom:&_state bit:PNConnectionErrorCleanAll];
                [PNBitwiseHelper addTo:&_state bits:PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR];
                
                [self reconnect];
            }
        }
        else if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainPOSIX] ||
                [errorDomain isEqualToString:(NSString *)kCFErrorDomainCFNetwork]) {

            [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] SOCKET GENERAL ERROR OCCURRED (STATE: %lu)",
                        self.name ? self.name : self, self.state];
            }];

            // Check whether connection should be reconnected because of critical error
            if ([self isConnectionIssuesError:error]) {

                [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] SOCKET ERROR BECAUSE OF INTERNET (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];

                if ([self isConnectionUplinkError:error]) {

                    [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] MAYBE UPLINK IS DOWN. (STATE: %lu)",
                                self.name ? self.name : self, self.state];
                    }];
                }

                if ([self canRetryConnection]) {

                    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] CONNECTION RETRY IS POSSIBLE (STATE: %lu)",
                                self.name ? self.name : self, self.state];
                    }];
                    
                    shouldCloseConnection = NO;
                    [self retryConnection];
                }
                else {

                    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] CONNECTION RETRY NOT POSSIBLE (STATE: %lu)",
                                self.name ? self.name : self, self.state];
                    }];
                    
                    // Mark that we should init streams close because of critical error
                    shouldCloseConnection = YES;
                }
            }
            
            if ([self isTemporaryError:error]) {
                
                [PNBitwiseHelper removeFrom:&_state bit:PNConnectionErrorCleanAll];
                [PNBitwiseHelper addTo:&_state bits:PNByInternalRequest, PNConnectionSocket, BITS_LIST_TERMINATOR];

                if ([self isServerError:error]) {

                    [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] SOCKET GENERAL ERROR BECAUSE OF SERVER ACTIONS (STATE: %lu)",
                                self.name ? self.name : self, self.state];
                    }];
                }
                else {

                    [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] SOCKET GENERAL ERROR BECAUSE OF TEMPORARY ISSUES WITH SOCKET (STATE: %lu)",
                                                  self.name ? self.name : self, self.state];
                    }];
                }
                
                // Checking whether connection is able to perform another connection attempt or not
                if ([self canRetryConnection]) {

                    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] CONNECTION RETRY IS POSSIBLE (STATE: %lu)",
                                self.name ? self.name : self, self.state];
                    }];

                    
                    shouldCloseConnection = NO;
                    [self retryConnection];
                }
                else {

                    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] CONNECTION RETRY NOT POSSIBLE (STATE: %lu)",
                                self.name ? self.name : self, self.state];
                    }];
                    
                    // Mark that we should init streams close because of critical error
                    shouldCloseConnection = YES;
                }
            }
        }

        if (shouldCloseConnection) {
            
            // Check whether we are tried to establish connection and some error occurred there
            if ([self isConnecting]) {

                shouldCloseConnection = [PNBitwiseHelper is:self.state containsBit:PNByUserRequest];
                if (!shouldCloseConnection) {
                    
                    [PNBitwiseHelper addTo:&_state bits:PNByInternalRequest, PNConnectionSocket, BITS_LIST_TERMINATOR];

                    [self retryConnection];
                }
                else {
                    
                    [PNBitwiseHelper removeFrom:&_state bit:PNConnectionSocket];
                }
            }
        }


        if (shouldCloseConnection) {

            // Check whether error occurred during data sending or not
            if ([PNBitwiseHelper is:self.state containsBit:PNConnectionProcessingRequests] && self.writeBuffer) {

                [self handleRequestProcessingError:error];
            }


            if ([self isConnected] && ![self isDisconnecting]) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] CLOSING STREAMS BECAUSE OF ERROR (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];
                
                [PNBitwiseHelper removeFrom:&_state bits:PNConnectionCleanReconnection, PNReadStreamCleanAll, PNWriteStreamCleanAll,
                 PNConnectionDisconnect, PNByServerRequest, PNByInternalRequest,PNByUserRequest,
                 PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR];
                
                self.connectionRetryCount = 0;
                [self.delegate connection:self willDisconnectFromHost:self.configuration.origin withError:errorObject];
                [self disconnectByInternalRequest];
            }
            else if ([self isConnecting]) {

                [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                    return [NSString stringWithFormat:@"[CONNECTION::%@] CLOSING STREAMS BECAUSE OF ERROR WHILE TRIED TO CONNECT (STATE: %lu)",
                            self.name ? self.name : self, self.state];
                }];
                
                [PNBitwiseHelper removeFrom:&_state bits:PNConnectionCleanReconnection, PNReadStreamCleanAll, PNWriteStreamCleanAll,
                 PNConnectionDisconnect, PNByServerRequest, PNByInternalRequest,PNByUserRequest,
                 PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR];
                
                self.connectionRetryCount = 0;
                [self.delegate connection:self connectionDidFailToHost:self.configuration.origin withError:errorObject];
                [self disconnectOnInternalRequest];
            }
        }
    }
}

- (void)handleStreamSetupError {

    [PNLogger logConnectionErrorMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@] HANDLE STREAM CONFIGURATION FAILURE (STATE: %lu)",
                self.name ? self.name : self, self.state];
    }];

    // Check whether error occurred while connection attempted to connect to remote services w/o configuration on
    // user request or not
    if ([PNBitwiseHelper is:self.state strictly:YES containsBits:PNByUserRequest, PNConnectionPrepareToConnect, BITS_LIST_TERMINATOR]) {

        // Prepare error message which will be sent to connection channel delegate
        PNError *setupError = [PNError errorWithCode:kPNConnectionErrorOnSetup];

        // Connection instance can't operate anymore, notify delegate about it's state
        [self.delegate connection:self connectionDidFailToHost:self.configuration.origin withError:setupError];
    }
    // Looks like error occurred during initial configuration or when reconnection has been called within library
    else {

        __pn_desired_weak __typeof__(self) weakSelf = self;
        int64_t delay = 1;
        if ([PNBitwiseHelper is:self.state strictly:YES containsBits:PNConnectionConfiguring, PNConnectionPrepareToConnect, BITS_LIST_TERMINATOR]) {

            delay = kPNConnectionRetryDelay;
        }
        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delay * NSEC_PER_SEC));

        void(^delayedBlock)(void) = ^{

            // Check whether connection is still in bad state before issue connection
            if ([PNBitwiseHelper is:weakSelf.state containsBit:PNConnectionConfiguring]) {

                if (weakSelf.configurationRetryCount + 1 < kPNMaximumConfigurationRetryCount) {

                    [PNLogger logConnectionErrorMessageFrom:weakSelf message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] RETRY CONFIGURATION ATTEMPT... (STATE: %lu)",
                                weakSelf.name ? weakSelf.name : weakSelf, weakSelf.state];
                    }];

                    weakSelf.configurationRetryCount++;

                    // Check whether client configuration failed during connection attempt or not
                    if ([PNBitwiseHelper is:weakSelf.state strictly:YES containsBits:PNConnectionConfiguring, PNConnectionPrepareToConnect,
                         BITS_LIST_TERMINATOR]) {

                        [weakSelf connectByInternalRequest];
                    }
                    else {

                        [weakSelf prepareStreams];
                    }
                }
                // Looks like connection instance can't retry anymore because it reached maximum retry count
                else {

                    [PNLogger logConnectionErrorMessageFrom:weakSelf message:^NSString * {

                        return [NSString stringWithFormat:@"[CONNECTION::%@] CONFIGURATION RETRY COUNT EXCEEDED LIMIT. CANCEL. (STATE: %lu)",
                                                  weakSelf.name ? weakSelf.name : weakSelf, weakSelf.state];
                    }];

                    weakSelf.configurationRetryCount = 0;
                    weakSelf.connectionRetryCount = 0;

                    // Terminate operation of all streams and buffers (clean up)
                    [weakSelf destroyStreams];
                    
                    [PNBitwiseHelper clear:&_state];
                    [PNBitwiseHelper addTo:&_state bit:PNConnectionDisconnected];

                    // Connection instance can't operate anymore, notify delegate about it's state
                    [weakSelf.delegate connectionConfigurationDidFail:weakSelf];
                }
            }
        };

        dispatch_after(popTime, dispatch_get_main_queue(), delayedBlock);
    }
}

- (void)handleRequestProcessingError:(CFErrorRef)error {

    if (error && CFErrorGetCode(error) != 0) {

        if (self.writeBuffer && [PNBitwiseHelper is:self.state containsBit:PNSendingData]) {

            [self.dataSource connection:self didFailToProcessRequestWithIdentifier:self.writeBuffer.requestIdentifier
                              withError:[self processStreamError:error]];
        }
    }
}


#pragma mark - Misc methods

- (void)startTimeoutTimer {

    [self stopTimeoutTimer];

    self.connectionTimeoutTimer = [NSTimer timerWithTimeInterval:kPNConnectionTimeout target:self
                                                        selector:@selector(handleTimeoutTimer:) userInfo:nil
                                                         repeats:NO];

    [[NSRunLoop currentRunLoop] addTimer:self.connectionTimeoutTimer forMode:NSRunLoopCommonModes];
}

- (void)stopTimeoutTimer {

    if ([self.connectionTimeoutTimer isValid]) {

        [self.connectionTimeoutTimer invalidate];
    }

    self.connectionTimeoutTimer = nil;
}

- (void)startWakeUpTimer {

    if (self.wakeUpTimer == NULL) {

        self.wakeUpTimerSuspended = YES;

        dispatch_source_t timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());
        [PNDispatchHelper retain:timerSource];
        self.wakeUpTimer = timerSource;
        __pn_desired_weak __typeof__(self) weakSelf = self;
        dispatch_source_set_event_handler(self.wakeUpTimer, ^{

            [weakSelf handleWakeUpTimer];
        });
        dispatch_source_set_cancel_handler(self.wakeUpTimer, ^{

            [PNDispatchHelper release:timerSource];
            weakSelf.wakeUpTimerSuspended = NO;
            weakSelf.wakeUpTimer = NULL;
        });

        [self resetWakeUpTimer];
    }

    if (self.isWakeUpTimerSuspended) {

        [self resumeWakeUpTimer];
    }
}

- (void)suspendWakeUpTimer {

    if (self.wakeUpTimer != NULL) {

        if (!self.isWakeUpTimerSuspended) {

            self.wakeUpTimerSuspended = YES;
            dispatch_suspend(self.wakeUpTimer);
        }
    }

    self.wakeUpTimerSuspended = NO;
}

- (void)resumeWakeUpTimer {

    if (self.wakeUpTimer == NULL) {

        [self startWakeUpTimer];
    }
    else {

        if (self.isWakeUpTimerSuspended) {

            self.wakeUpTimerSuspended = NO;
            [self resetWakeUpTimer];
            dispatch_resume(self.wakeUpTimer);
        }
    }
}

- (void)stopWakeUpTimer {

    if (self.wakeUpTimer != NULL) {

        if (self.isWakeUpTimerSuspended) {

            [self resumeWakeUpTimer];
        }
        self.wakeUpTimerSuspended = NO;
        dispatch_source_cancel(self.wakeUpTimer);
    }
}

- (void)resetWakeUpTimer {

    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(kPNWakeUpTimerInterval * NSEC_PER_SEC));
    dispatch_source_set_timer(self.wakeUpTimer, start, (int64_t)(kPNWakeUpTimerInterval * NSEC_PER_SEC), NSEC_PER_SEC);
}

- (CFStreamClientContext)streamClientContext {

    return (CFStreamClientContext){0, (__bridge void *)(self), NULL, NULL, NULL};
}

- (CFMutableDictionaryRef)streamSecuritySettings {

    if (self.configuration.shouldUseSecureConnection && _streamSecuritySettings == NULL &&
        self.sslConfigurationLevel != PNConnectionSSLConfigurationInsecure) {

        // Configure security settings
        _streamSecuritySettings = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 6, NULL, NULL);
        CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLLevel, kCFStreamSocketSecurityLevelSSLv3);
        CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLPeerName, kCFNull);
        if (self.sslConfigurationLevel == PNConnectionSSLConfigurationStrict) {

            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLValidatesCertificateChain, kCFBooleanTrue);
        }
        else {

            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLValidatesCertificateChain, kCFBooleanFalse);
        }
    }
    else if (!self.configuration.shouldUseSecureConnection ||
             self.sslConfigurationLevel == PNConnectionSSLConfigurationInsecure) {
        
        [PNHelper releaseCFObject:&_streamSecuritySettings];
    }


    return _streamSecuritySettings;
}

- (void)retrieveSystemProxySettings {

    if (self.proxySettings == NULL) {

        [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

            return [NSString stringWithFormat:@"[CONNECTION::%@] FETCHING PROXY CONFIGURATION SETTINGS (STATE: %lu)",
                    self.name ? self.name : self, self.state];
        }];

        // Fetch list of all available proxy settings in system
        CFDictionaryRef proxiesList = CFNetworkCopySystemProxySettings();

        if (proxiesList) {

            NSString *scheme = @"http";
            if (self.streamSecuritySettings != NULL) {

                scheme = @"https";
            }

            // Construct URL basing on which system will return list of proxy settings which can be used to open
            // socket
            NSURL *targetHost = [NSURL URLWithString:[NSString stringWithFormat:@"%@://%@", scheme, self.configuration.origin]];

            // Retrieve list of proxy settings which can be used to reach specific resources
            CFArrayRef suitableProxies = CFNetworkCopyProxiesForURL((__bridge CFURLRef)targetHost, proxiesList);

            if (CFArrayGetCount(suitableProxies) > 0) {

                // Retrieve reference on first suitable proxy settings
                CFDictionaryRef suitableProxySettings = CFArrayGetValueAtIndex(suitableProxies, 0);

                if (suitableProxySettings != NULL) {

                    self.proxySettings = CFBridgingRelease(CFDictionaryCreateCopy(kCFAllocatorDefault, suitableProxySettings));
                }
            }
            CFRelease(suitableProxies);
            CFRelease(proxiesList);

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] PROXY CONFIGURATION SETTINGS: %@\n(STATE: %lu)",
                        self.name ? self.name : self, self.proxySettings, self.state];
            }];
        }
        else {

            [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

                return [NSString stringWithFormat:@"[CONNECTION::%@] THERE IS NO PROXY CONFIGURATION IN SYSTEM "
                        "(STATE: %lu)", self.name ? self.name : self, self.state];
            }];
        }
    }
}

/**
 * Lazy data holder creation
 */
- (NSMutableData *)retrievedData {

    if (_retrievedData == nil) {

        _retrievedData = [NSMutableData dataWithCapacity:kPNStreamBufferSize];
    }


    return _retrievedData;
}

- (NSMutableData *)temporaryRetrievedData {

    if (_temporaryRetrievedData == nil) {

        _temporaryRetrievedData = [NSMutableData dataWithCapacity:kPNStreamBufferSize];
    }


    return _temporaryRetrievedData;
}

- (PNError *)processStreamError:(CFErrorRef)error {

    PNError *errorInstance = nil;

    if (error) {

        NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);

        if ([self isConnectionIssuesError:error]) {

            int errorCode = kPNClientConnectionClosedOnInternetFailureError;
            if (self.writeBuffer != nil && [self.writeBuffer hasData] && self.writeBuffer.isSendingBytes) {

                errorCode = kPNRequestExecutionFailedOnInternetFailureError;
            }

            errorInstance = [PNError errorWithCode:errorCode];
        }
        else if ([self isSecurityTransportError:error]) {

            errorInstance = [PNError errorWithCode:kPNClientConnectionClosedOnSSLNegotiationFailureError];
        }
        else if ([self isTemporaryError:error]) {
            
            NSInteger errorCode = kPNClientConnectionClosedOnSocketsError;
            if ([self isServerError:error]) {
                
                errorCode = kPNClientConnectionClosedOnServerRequestError;
            }
            
            errorInstance = [PNError errorWithCode:errorCode];
        }
        else {

            errorInstance = [PNError errorWithDomain:errorDomain code:CFErrorGetCode(error) userInfo:nil];
        }
    }


    return errorInstance;
}

- (NSString *)stateDescription {

    NSMutableString *connectionState = [NSMutableString stringWithFormat:@"\n[CONNECTION::%@ STATE DESCRIPTION",
                                        self.name ? self.name : self];
    if ([PNBitwiseHelper is:self.state containsBit:PNReadStreamConfiguring]) {

        [connectionState appendFormat:@"\n- READ STREAM CONFIGURATION..."];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNWriteStreamConfiguring]) {

        [connectionState appendFormat:@"\n- WRITE STREAM CONFIGURATION..."];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNReadStreamConfigured]) {

        [connectionState appendFormat:@"\n- READ STREAM CONFIGURED"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNWriteStreamConfigured]) {

        [connectionState appendFormat:@"\n- WRITE STREAM CONFIGURED"];
    }
    NSString *actionSource = @"";
    NSString *actionSourceReason = @"";
    if ([PNBitwiseHelper is:self.state containsBit:PNConnectionWakeUpTimer]) {

        actionSource = @"WAKE UP TIMER";
        actionSourceReason = @" (BY WAKE UP TIMER REQUEST)";
    }
    else if ([PNBitwiseHelper is:self.state containsBit:PNConnectionSSL]) {

        actionSource = @"SSL LAYER";
        actionSourceReason = @" (BY SSL LAYER REQUEST)";
    }
    else if ([PNBitwiseHelper is:self.state containsBit:PNConnectionSocket]) {

        actionSource = @"SOCKET LAYER";
        actionSourceReason = @" (BY SOCKET LAYER REQUEST)";
    }
    [connectionState appendFormat:@"\n- ACTION SOURCE: %@...", actionSource];
    if ([PNBitwiseHelper is:self.state containsBit:PNReadStreamConnecting]) {

        [connectionState appendFormat:@"\n- READ STREAM CONNECTING%@...", actionSourceReason];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNWriteStreamConnecting]) {

        [connectionState appendFormat:@"\n- WRITE STREAM CONNECTING%@...", actionSourceReason];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNReadStreamConnected]) {

        [connectionState appendFormat:@"\n- READ STREAM CONNECTED"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNWriteStreamConnected]) {

        [connectionState appendFormat:@"\n- WRITE STREAM CONNECTED"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNConnectionPrepareToConnect]) {

        [connectionState appendFormat:@"\n- PREPARING TO CONNECT..."];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNByInternalRequest]) {

        [connectionState appendFormat:@"\n- CURRENT ACTION PERFORMED BY INTERNAL REQUEST"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNByUserRequest]) {

        [connectionState appendFormat:@"\n- CURRENT ACTION PERFORMED BY USER REQUEST"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNByServerRequest]) {

        [connectionState appendFormat:@"\n- CONNECTION CLOSE WAS EXPECTED (PROBABLY SERVER DOESN'T SUPPORT "
                "'keep-alive' CONNECTION TYPE)"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNConnectionResuming]) {

        [connectionState appendFormat:@"\n- RESUMING..."];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNConnectionReconnect]) {

        [connectionState appendFormat:@"\n- RECONNECTING..."];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNReadStreamDisconnecting]) {

        [connectionState appendFormat:@"\n- READ STREAM DISCONNECTING%@...", actionSourceReason];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNWriteStreamDisconnecting]) {

        [connectionState appendFormat:@"\n- WRITE STREAM DISCONNECTING%@...", actionSourceReason];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNConnectionSuspending]) {

        [connectionState appendFormat:@"\n- SUSPENDING..."];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNReadStreamDisconnected]) {

        [connectionState appendFormat:@"\n- READ STREAM DISCONNECTED"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNWriteStreamDisconnected]) {

        [connectionState appendFormat:@"\n- WRITE STREAM DISCONNECTED"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNConnectionReconnectOnDisconnect]) {

        [connectionState appendFormat:@"\n- WAITING FOR DISCONNECTION TO CONNECT BACK"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNConnectionSuspended]) {

        [connectionState appendFormat:@"\n- SUSPENDED"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNConnectionProcessingRequests]) {

        [connectionState appendFormat:@"\n- REQUEST PROCESSING ENABLED"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNSendingData]) {

        [connectionState appendFormat:@"\n- SENDING DATA"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNReadStreamError]) {

        [connectionState appendFormat:@"\n- READ STREAM ERROR"];
    }
    if ([PNBitwiseHelper is:self.state containsBit:PNWriteStreamError]) {

        [connectionState appendFormat:@"\n- WRITE STREAM ERROR"];
    }


    return connectionState;
}


#pragma mark - Memory management

- (void)prepareForTermination {

    [self stopWakeUpTimer];
    [self stopTimeoutTimer];
}

- (void)dealloc {

    // Closing all streams and free up resources which was allocated for their support
    [self destroyStreams];
    [self stopWakeUpTimer];
    [self stopTimeoutTimer];
    _delegate = nil;
    _proxySettings = nil;

    [PNLogger logConnectionInfoMessageFrom:self message:^NSString * {

        return [NSString stringWithFormat:@"[CONNECTION::%@] DESTROYED (STATE: %lu)", _name ? _name : self, _state];
    }];
    
    [PNHelper releaseCFObject:&_streamSecuritySettings];
}

#pragma mark -


@end
