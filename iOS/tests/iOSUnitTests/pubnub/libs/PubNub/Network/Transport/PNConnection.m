//
//  PNConnection.m
//  pubnub
//
//  This is core class for communication over
//  the network with PubNub services.
//  It allow to establish socket connection and
//  organize write packet requests into FIFO queue.
//
//  Created by Sergey Mamontov on 12/10/12.
//
//

#import "PNConnection.h"
#import <SystemConfiguration/SystemConfiguration.h>
#import <Security/SecureTransport.h>
#import "PNConnection+Protected.h"
#import "PNResponseDeserialize.h"
#import "PNResponseProtocol.h"
#import "PubNub+Protected.h"
#import "PNWriteBuffer.h"


// ARC check
#if !__has_feature(objc_arc)
#error PubNub connection must be built with ARC.
// You can turn on ARC for only PubNub files by adding '-fobjc-arc' to the build phase for each of its files.
#endif


#pragma mark Structures

typedef NS_OPTIONS(NSUInteger, PNConnectionActionSourceFlag)  {

    // Flag which allow to set action has been generated by 'wake up' timer or not
    PNConnectionWakeUpTimer = 1 << 0,

    // Flag which allow to set whether action has been generated by SSL layer from error handling or not
    PNConnectionSSL = 1 << 1,

    // Flag which allow to set whether action has been generated from socket error handling or not
    PNConnectionSocket = 1 << 2
};

typedef NS_OPTIONS(NSUInteger, PNConnectionActionFlag)  {

    // Flag which allow to set whether client is reconnecting at this moment or not
    PNConnectionReconnect = 1 << 3,

    // Flag which allow to set whether client should connect back as soon as disconnection will be completed or not
    PNConnectionReconnectOnDisconnect = 1 << 4,

    // Flag which allow to set whether client should disconnect or not
    PNConnectionDisconnect = 1 << 5
};

typedef NS_OPTIONS(NSUInteger, PNConnectionActionOwnerFlag)  {

    // Flag which allow to set whether action on connection has been triggered by user or not
    PNByUserRequest = 1 << 6,

    // Flag which allow to set whether action on connection has been triggered by internal code or not
    PNByInternalRequest = 1 << 7,

    // Flag which allow to set whether action on connection has been triggered by server or not
    PNByServerRequest = 1 << 8
};

typedef NS_OPTIONS(NSUInteger, PNConnectionStateFlag)  {

    // Flag which allow to set whether read stream configuration started or not
    PNReadStreamConfiguring = 1 << 9,

    // Flag which allow to set whether write stream configuration started or not
    PNWriteStreamConfiguring = 1 << 10,

    // Flag which allow to set whether connection configuration started or not
    PNConnectionConfiguring = (PNReadStreamConfiguring | PNWriteStreamConfiguring),

    // Flag which allow to set whether read stream configured or not
    PNReadStreamConfigured = 1 << 11,

    // Flag which allow to set whether write stream configured or not
    PNWriteStreamConfigured = 1 << 12,

    // Flag which allow to set whether connection configured or not
    PNConnectionConfigured = (PNReadStreamConfigured | PNWriteStreamConfigured),

    // Flag which allow to set whether read stream is connecting right now or not
    PNReadStreamConnecting = 1 << 13,

    // Flag which allow to set whether write stream is connecting right now or not
    PNWriteStreamConnecting = 1 << 14,

    // Flag which allow to set whether client is connecting at this moment or not
    PNConnectionConnecting = (PNReadStreamConnecting | PNWriteStreamConnecting),

    // Flag which allow to set whether read stream is connected right now or not
    PNReadStreamConnected = 1 << 15,

    // Flag which allow to set whether write stream is connected right now or not
    PNWriteStreamConnected = 1 << 16,

    // Flag which allow to set whether connection channel is preparing to establish connection
    PNConnectionPrepareToConnect = 1 << 17,

    // Flag which allow to set whether client is connected or not
    PNConnectionConnected = (PNReadStreamConnected | PNWriteStreamConnected),

    // Flag which allow to set whether connection is suspended or not or not
    PNConnectionResuming = 1 << 18,

    // Flag which allow to set whether read stream is disconnecting right now or not
    PNReadStreamDisconnecting = 1 << 19,

    // Flag which allow to set whether write stream is disconnecting right now or not
    PNWriteStreamDisconnecting = 1 << 20,

    // Flag which allow to set whether client is disconnecting at this moment or not
    PNConnectionDisconnecting = (PNReadStreamDisconnecting | PNWriteStreamDisconnecting),

    // Flag which allow to set whether connection is suspending or not or not
    PNConnectionSuspending = 1 << 21,

    // Flag which allow to set whether read stream is disconnected right now or not
    PNReadStreamDisconnected = 1 << 22,

    // Flag which allow to set whether write stream is disconnected right now or not
    PNWriteStreamDisconnected = 1 << 23,

    // Flag which allow to set whether client is disconnected at this moment or not
    PNConnectionDisconnected = (PNReadStreamDisconnected | PNWriteStreamDisconnected),

    // Flag which stores all states which is responsible for connection 'reconnect' state
    PNConnectionReconnection = (PNConnectionReconnect | PNConnectionReconnectOnDisconnect),

    // Flag which allow to set whether connection is suspended or not or not
    PNConnectionSuspended = 1 << 24,

    // Flag which allow to set whether connection should schedule next requests or not
    PNConnectionProcessingRequests = 1 << 25
};

typedef NS_OPTIONS(NSUInteger, PNConnectionDataSendingStateFlag)  {

    // Flag which allow to set whether action on connection has been triggered by user or not
    PNSendingData = 1 << 26
};

typedef NS_OPTIONS(NSUInteger, PNConnectionErrorStateFlag)  {

    // Flag which allow to set whether error occurred on read stream or not
    PNReadStreamError = 1 << 27,

    // Flag which allow to set whether error occurred on write stream or not
    PNWriteStreamError = 1 << 28,

    // Flag which allow to set whether client is experiencing some error or not
    PNConnectionError = (PNReadStreamError | PNWriteStreamError)
};

typedef NS_OPTIONS(NSUInteger, PNConnectionCleanStateFlag)  {

    // Flag which can be used to clean configuration states related to read stream
    PNReadStreamCleanConfiguration = (PNReadStreamConfiguring | PNReadStreamConfigured),

    // Flag which can be used to clean connection states related to read stream
    PNReadStreamCleanConnection = (PNReadStreamConnecting | PNReadStreamConnected),

    // Flag which can be used to clean connection states related to read stream
    PNReadStreamCleanDisconnection = (PNReadStreamDisconnecting | PNReadStreamDisconnected),

    // Flag which can be used to clean all states related to read stream
    PNReadStreamCleanAll = (PNReadStreamCleanConfiguration | PNReadStreamCleanConnection |
                            PNReadStreamCleanDisconnection | PNReadStreamError),

    // Flag which can be used to clean configuration states related to write stream
    PNWriteStreamCleanConfiguration = (PNWriteStreamConfiguring | PNWriteStreamConfigured),

    // Flag which can be used to clean connection states related to write stream
    PNWriteStreamCleanConnection = (PNWriteStreamConnecting | PNWriteStreamConnected),

    // Flag which can be used to clean connection states related to write stream
    PNWriteStreamCleanDisconnection = (PNWriteStreamDisconnecting | PNWriteStreamDisconnected),

    // Flag which can be used to clean all states related to write stream
    PNWriteStreamCleanAll = (PNWriteStreamCleanConfiguration | PNWriteStreamCleanConnection |
                             PNWriteStreamCleanDisconnection | PNWriteStreamError),

    // Flag which allow to clean up connection 'reconnection' state
    PNConnectionCleanReconnection = PNConnectionReconnection,

    // Flag which allow to set whether client is experiencing some error or not
    PNConnectionErrorCleanAll = (PNReadStreamError | PNWriteStreamError)
};

typedef enum _PNConnectionSSLConfigurationLevel {

    // This option will check all information on remote origin SSL certificate to ensure in authority
    PNConnectionSSLConfigurationStrict,

    // This option will skip most of validations and as fact will allow to work with server which uses invalid SSL
    // certificate or certificate from another server
    PNConnectionSSLConfigurationBarelySecure,

    // This option will tell that connection should be opened w/o SSL (if user won't to discard security options)
    PNConnectionSSLConfigurationInsecure,
} PNConnectionSSLConfigurationLevel;

struct PNConnectionIdentifiersStruct PNConnectionIdentifiers = {
    
    .messagingConnection = @"PNMessagingConnectionIdentifier",
    .serviceConnection = @"PNServiceConnectionIdentifier"
};


#pragma mark - Static

// Stores reference on created connection instances which can be used/reused
static NSMutableDictionary *_connectionsPool = nil;
static dispatch_once_t onceToken;

// Delay which is used by wake up timer to fire
static int64_t const kPNWakeUpTimerInterval = 5;

// Default origin host connection port
static UInt32 const kPNOriginConnectionPort = 80;

// Default origin host SSL connection port
static UInt32 const kPNOriginSSLConnectionPort = 443;

// Default data buffer size (Default: 32kb)
static int const kPNStreamBufferSize = 32768;

// Default connection attempt timeout (Default: 10s)
static int const kPNConnectionTimeout = 10.0f;

// Delay after which connection should retry
static int64_t const kPNConnectionRetryDelay = 2;
static NSTimeInterval const kPNConnectionRetryFastDelay = 0.1f;

// Maximum retry count which can be performed for configuration operation
static NSUInteger const kPNMaximumConfigurationRetryCount = 3;

// Maximum connection retry count which can be performed before library will report connection error
static NSUInteger const kPNMaximumConnectionRetryCount = 3;


#pragma mark - Private interface methods

@interface PNConnection ()

#pragma mark - Properties

// Stores connection name (identifier)
@property (nonatomic, copy) NSString *name;

// Connection configuration information
@property (nonatomic, strong) PNConfiguration *configuration;

// Stores reference on response deserializer which will parse response into objects array and update provided data to
// insert offset on amount of parsed data
@property (nonatomic, strong) PNResponseDeserialize *deserializer;

// Stores reference on binary data object which stores server response from socket read stream
@property (nonatomic, strong) NSMutableData *retrievedData;

// Stores reference on binary data object which temporary stores data received from socket read stream (used while
// deserializer is working)
@property (nonatomic, strong) NSMutableData *temporaryRetrievedData;

// Stores reference on buffer which should be sent to the PubNub service via socket
@property (nonatomic, strong) PNWriteBuffer *writeBuffer;

@property (nonatomic, assign) NSUInteger configurationRetryCount;
@property (nonatomic, assign) NSUInteger connectionRetryCount;

// Stores connection channel state
@property (nonatomic, assign) unsigned long state;

// Stores reference on timer which should awake connection channel if it doesn't reconnect back because of some
// race of states and conditions
@property (nonatomic, pn_dispatch_property_ownership) dispatch_source_t wakeUpTimer;
@property (nonatomic, assign, getter = isWakeUpTimerSuspended) BOOL wakeUpTimerSuspended;

@property (nonatomic, strong) NSTimer *connectionTimeoutTimer;

// Socket streams and state
@property (nonatomic, assign) CFReadStreamRef socketReadStream;
@property (nonatomic, assign) CFWriteStreamRef socketWriteStream;
@property (nonatomic, assign, getter = isWriteStreamCanHandleData) BOOL writeStreamCanHandleData;

// Socket streams configuration and security
@property (nonatomic, strong) NSDictionary *proxySettings;
@property (nonatomic, assign) CFMutableDictionaryRef streamSecuritySettings;
@property (nonatomic, assign) PNConnectionSSLConfigurationLevel sslConfigurationLevel;


#pragma mark - Class methods

/**
 * Retrieve reference on connection with specified identifier from connections pool
 */
+ (PNConnection *)connectionFromPoolWithIdentifier:(NSString *)identifier;

/**
 * Store connection instance inside connections pool
 */
+ (void)storeConnection:(PNConnection *)connection withIdentifier:(NSString *)identifier;

/**
 * Returns reference on dictionary of connections (it will be created on runtime)
 */
+ (NSMutableDictionary *)connectionsPool;


#pragma mark - Instance methods

/**
 * Perform connection initialization with user-provided configuration (they will be obtained from PubNub client)
 */
- (id)initWithConfiguration:(PNConfiguration *)configuration;


#pragma mark - Streams management methods

/**
 * Will create read/write pair streams to specific host at
 */
- (BOOL)prepareStreams;

- (void)disconnectOnInternalRequest;

/**
 * Will destroy both read and write streams
 */
- (void)destroyStreams;

/**
 * Allow to configure read stream with set of parameters like:
 *   - proxy
 *   - security (SSL)
 * If stream already configured, it won't accept any new settings.
 */
- (void)configureReadStream:(CFReadStreamRef)readStream;
- (void)openReadStream:(CFReadStreamRef)readStream;
- (void)disconnectReadStream:(CFReadStreamRef)readStream;
- (void)destroyReadStream:(CFReadStreamRef)readStream;

/**
 * Process response which was fetched from read stream so far
 */
- (void)processResponse;

/**
 * Read out content which is waiting in read stream
 */
- (void)readStreamContent;

/**
 * Allow to complete write stream configuration (additional settings will be transferred from paired read stream on
 * configuration). If stream already configured, it won't accept any new settings.
 */
- (void)configureWriteStream:(CFWriteStreamRef)writeStream;
- (void)openWriteStream:(CFWriteStreamRef)writeStream;
- (void)disconnectWriteStream:(CFWriteStreamRef)writeStream;
- (void)destroyWriteStream:(CFWriteStreamRef)writeStream;

/**
 * Retrieve and prepare next request which should be sent
 */
- (void)prepareNextRequestPacket;

/**
 * Writes buffer portion into socket
 */
- (void)writeBufferContent;


#pragma mark - Handler methods

/**
 * Called every time when one of streams (read/write) successfully open connection
 */
- (void)handleStreamConnection;

/**
 * Called every time when one of streams (read/write) disconnected
 */
- (void)handleStreamClose;

/**
 * Called each time when new portion of data available in socket read stream for reading
 */
- (void)handleReadStreamHasData;

/**
 * Called each time when write stream is ready to accept data from PubNub client
 */
- (void)handleWriteStreamCanAcceptData;

/**
 * Called when client is about to close write stream and we need to do something with write buffer if it was assigned
 */
- (void)handleRequestSendingCancelation;

/**
 * Called each time when server close stream because of timeout
 */
- (void)handleStreamTimeout;

- (void)handleTimeoutTimer:(NSTimer *)timer;

/**
 * Called each time when wake up timer is fired
 */
- (void)handleWakeUpTimer;

/**
 * Converts stream status enum value into string representation
 */
- (NSString *)stringifyStreamStatus:(CFStreamStatus)status;

- (void)handleStreamError:(CFErrorRef)error;
- (void)handleStreamError:(CFErrorRef)error shouldCloseConnection:(BOOL)shouldCloseConnection;
- (void)handleStreamSetupError;
- (void)handleRequestProcessingError:(CFErrorRef)error;


#pragma mark - Misc methods

/**
 * Start/stop connection timeout timer
 */
- (void)startTimeoutTimer;
- (void)stopTimeoutTimer;

/**
 * Construct/reuse and launch/resume/suspend/stop 'wakeup' timer to help restore connection if it will be required
 */
- (void)startWakeUpTimer;
- (void)suspendWakeUpTimer;
- (void)resumeWakeUpTimer;
- (void)stopWakeUpTimer;
- (void)resetWakeUpTimer;

/**
 * Check whether specified error is from POSIX domain and report that error is caused by connection failure or not
 */
- (BOOL)isConnectionIssuesError:(CFErrorRef)error;
- (BOOL)isConnectionUplinkError:(CFErrorRef)error;

/**
 * Check whether specified error is from OSStatus error domain and report that error is caused by SSL issue
 */
- (BOOL)isSecurityTransportError:(CFErrorRef)error;
- (BOOL)isInternalSecurityTransportError:(CFErrorRef)error;
- (BOOL)isTemporaryError:(CFErrorRef)error;
- (BOOL)isServerError:(CFErrorRef)error;

- (CFStreamClientContext)streamClientContext;

/**
 * Retrieving global network proxy configuration
 */
- (void)retrieveSystemProxySettings;

/**
 * Stream error processing methods
 */
- (PNError *)processStreamError:(CFErrorRef)error;

/**
 * Print our current connection state
 */
- (NSString *)stateDescription;


@end


#pragma mark - Public interface methods

@implementation PNConnection

#pragma mark - Class methods

+ (PNConnection *)connectionWithIdentifier:(NSString *)identifier {

    // Try to retrieve connection from pool
    PNConnection *connection = [self connectionFromPoolWithIdentifier:identifier];

    if (connection == nil) {

        connection = [[[self class] alloc] initWithConfiguration:[PubNub sharedInstance].configuration];
        connection.name = identifier;
        [self storeConnection:connection withIdentifier:identifier];
    }


    return connection;
}

+ (PNConnection *)connectionFromPoolWithIdentifier:(NSString *)identifier {

    return [[self connectionsPool] valueForKey:identifier];
}

+ (void)storeConnection:(PNConnection *)connection withIdentifier:(NSString *)identifier {

    [[self connectionsPool] setValue:connection forKey:identifier];
}

+ (void)destroyConnection:(PNConnection *)connection {

    if (connection != nil) {

        // Iterate over the list of connection pool and remove connection from it
        NSMutableArray *connectionIdentifiersForDelete = [NSMutableArray array];
        [[self connectionsPool] enumerateKeysAndObjectsUsingBlock:^(id connectionIdentifier, id connectionFromPool,
                                                                    BOOL *connectionEnumeratorStop) {

            // Check whether found connection in connection pool or not
            if (connectionFromPool == connection) {

                // Adding identifier to the list of keys which should be removed (there can be many keys for single
                // connection because of performance and network issues on iOS)
                [connectionIdentifiersForDelete addObject:connectionIdentifier];
            }
        }];

        [[self connectionsPool] removeObjectsForKeys:connectionIdentifiersForDelete];
    }
}

+ (void)closeAllConnections {

    // Check whether has some connection in pool or not
    if ([_connectionsPool count] > 0) {

        // Store list of connections before purge connections pool
        NSArray *connections = [_connectionsPool allValues];

        // Clean up connections pool
        [_connectionsPool removeAllObjects];


        // Close all connections
        [connections makeObjectsPerformSelector:@selector(disconnectOnInternalRequest)];
    }
}

+ (NSMutableDictionary *)connectionsPool {

    dispatch_once(&onceToken, ^{

        _connectionsPool = [NSMutableDictionary new];
    });


    return _connectionsPool;
}

+ (void)resetConnectionsPool {

    onceToken = 0;

    // Reset connections
    if ([_connectionsPool count]) {

        [[_connectionsPool allValues] makeObjectsPerformSelector:@selector(prepareForTermination) withObject:nil];
        [[_connectionsPool allValues] makeObjectsPerformSelector:@selector(setDataSource:) withObject:nil];
        [[_connectionsPool allValues] makeObjectsPerformSelector:@selector(setDelegate:) withObject:nil];
    }

    _connectionsPool = nil;
}


#pragma mark - Instance methods

- (id)initWithConfiguration:(PNConfiguration *)configuration {

    // Check whether initialization was successful or not
    if ((self = [super init])) {

        // Perform connection initialization
        self.configuration = configuration;
        self.deserializer = [PNResponseDeserialize new];

        // Set initial connection state
        PNBitOn(&_state, PNConnectionDisconnected);
        
        // Perform streams initial options and security initializations
        [self prepareStreams];
    }


    return self;
}


#pragma mark - Requests queue execution management

- (void)scheduleNextRequestExecution {

    PNBitOn(&_state, PNConnectionProcessingRequests);

    // Ensure that both streams connected at this moment and connection doesn't try to close or suspend
    if ([self isConnected] && ![self isDisconnecting] && ![self isSuspending]) {

        // Check whether sending data at this moment or not
        if (!PNBitIsOn(self.state, PNSendingData) || ![self.writeBuffer isSendingBytes]) {

            if (self.writeBuffer == nil) {

                PNBitOff(&_state, PNSendingData);
                [self prepareNextRequestPacket];
            }
            else {

                [self.writeBuffer reset];
            }

            if (self.writeBuffer != nil) {

                // Try to initiate request sending process
                [self writeBufferContent];
            }
        }
        else {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] ALREADY SENDING DATA (STATE: %d)",
                    self.name ? self.name : self, self.state);
        }
    }
}

- (void)unscheduleRequestsExecution {

    PNBitOff(&_state, PNConnectionProcessingRequests);

    [self handleRequestSendingCancelation];
}


#pragma mark - Streams callback methods

void readStreamCallback(CFReadStreamRef stream, CFStreamEventType type, void *clientCallBackInfo) {

    NSCAssert([(__bridge id)clientCallBackInfo isKindOfClass:[PNConnection class]],
              @"{ERROR}[READ] WRONG CLIENT INSTANCE HAS BEEN SENT AS CLIENT");
    PNConnection *connection = (__bridge PNConnection *)clientCallBackInfo;

    NSString *status = [connection stringifyStreamStatus:CFReadStreamGetStatus(stream)];

    switch (type) {

        // Stream successfully opened
        case kCFStreamEventOpenCompleted:

            PNLog(PNLogConnectionLayerInfoLevel, connection, @"[CONNECTION::%@::READ] STREAM OPENED (%@)(STATE: %d)",
                  connection.name ? connection.name : connection, status, connection.state);

            PNBitOff(&(connection->_state), PNReadStreamCleanDisconnection);
            PNBitOn(&(connection->_state), PNReadStreamConnected);

            [connection handleStreamConnection];
            break;

        // Read stream has some data which arrived from remote server
        case kCFStreamEventHasBytesAvailable:

            PNLog(PNLogConnectionLayerInfoLevel, connection, @"[CONNECTION::%@::READ] HAS DATA FOR READ OUT (%@)(STATE: %d)",
                  connection.name ? connection.name : connection, status, connection.state);

            [connection handleReadStreamHasData];
            break;

        // Some error occurred on read stream
        case kCFStreamEventErrorOccurred:

            PNLog(PNLogConnectionLayerErrorLevel, connection, @"[CONNECTION::%@::READ] ERROR OCCURRED (%@)(STATE: %d)",
                  connection.name ? connection.name : connection, status, connection.state);

            // Mark that read stream caught and error
            PNBitOn(&(connection->_state), PNReadStreamError);

            CFErrorRef error = CFReadStreamCopyError(stream);
            [connection handleStreamError:error shouldCloseConnection:YES];

            PNCFRelease(&error);
            break;

        // Server disconnected socket probably because of timeout
        case kCFStreamEventEndEncountered:

            PNLog(PNLogConnectionLayerInfoLevel, connection, @"[CONNECTION::%@::READ] NOTHING TO READ (%@)(STATE: %d)",
                  connection.name ? connection.name : connection, status, connection.state);

            PNBitOff(&(connection->_state), PNReadStreamCleanAll);
            PNBitOn(&(connection->_state), PNReadStreamDisconnected);

            [connection handleStreamTimeout];
            break;

        default:
            break;
    }
}

void writeStreamCallback(CFWriteStreamRef stream, CFStreamEventType type, void *clientCallBackInfo) {

    NSCAssert([(__bridge id)clientCallBackInfo isKindOfClass:[PNConnection class]],
              @"{ERROR}[WRITE] WRONG CLIENT INSTANCE HAS BEEN SENT AS CLIENT");
    PNConnection *connection = (__bridge PNConnection *)clientCallBackInfo;

    NSString *status = [connection stringifyStreamStatus:CFWriteStreamGetStatus(stream)];

    switch (type) {

        // Stream successfully opened
        case kCFStreamEventOpenCompleted:

            PNLog(PNLogConnectionLayerInfoLevel, connection, @"[CONNECTION::%@::WRITE] STREAM OPENED (%@)(STATE: %d)",
                  connection.name ? connection.name : connection, status, connection.state);

            PNBitOff(&(connection->_state), PNWriteStreamCleanDisconnection);
            PNBitOn(&(connection->_state), PNWriteStreamConnected);

            [connection handleStreamConnection];
            break;

        // Write stream is ready to accept data from data source
        case kCFStreamEventCanAcceptBytes:

            PNLog(PNLogConnectionLayerInfoLevel, connection, @"[CONNECTION::%@::WRITE] READY TO SEND (%@)(STATE: %d)",
                  connection.name ? connection.name : connection, status, connection.state);

            [connection handleWriteStreamCanAcceptData];
            break;

        // Some error occurred on write stream
        case kCFStreamEventErrorOccurred:

            PNLog(PNLogConnectionLayerErrorLevel, connection, @"[CONNECTION::%@::WRITE] ERROR OCCURRED (%@)(STATE: %d)",
                  connection.name ? connection.name : connection, status, connection.state);

            // Mark that write stream caught and error
            PNBitOn(&(connection->_state), PNWriteStreamError);

            CFErrorRef error = CFWriteStreamCopyError(stream);
            [connection handleStreamError:error shouldCloseConnection:YES];

            PNCFRelease(&error);
            break;

        // Server disconnected socket probably because of timeout
        case kCFStreamEventEndEncountered:

            PNLog(PNLogConnectionLayerInfoLevel, connection, @"[CONNECTION::%@::WRITE] MAYBE STREAM IS CLOSED (%@)(STATE: %d)",
                  connection.name ? connection.name : connection, status, connection.state);

            PNBitOff(&(connection->_state), PNWriteStreamCleanAll);
            PNBitOn(&(connection->_state), PNWriteStreamDisconnected);

            [connection handleStreamTimeout];
            break;

        default:
            break;
    }
}


#pragma mark - Connection state

- (BOOL)isConnecting {

    // If at least one of the streams is connecting now treat it all as true
    return PNBitStrictIsOn(self.state, PNConnectionDisconnected) && PNBitIsOn(self.state, PNConnectionConnecting);
}

- (BOOL)isReconnecting {

    // If at least one of the streams is connecting now treat it all as true
    return PNBitIsOn(self.state, PNConnectionConnecting) && PNBitIsOn(self.state, PNConnectionReconnection);
}

- (BOOL)shouldReconnect {

    return PNBitIsOn(self.state, PNConnectionReconnection);
}

- (BOOL)isConnected {

    return PNBitStrictIsOn(self.state, PNConnectionConnected) && ![self isReconnecting];
}

- (BOOL)isDisconnected {

    return (PNBitStrictIsOn(self.state, PNConnectionDisconnected) || PNBitIsOn(self.state, PNConnectionSuspended)) &&
            ![self isConnecting];
}

- (BOOL)isDisconnecting {

    // If at least one of the streams is disconnecting now treat it all as true
    return PNBitIsOn(self.state, PNConnectionDisconnecting);
}


#pragma mark - Error identification

- (BOOL)isConnectionIssuesError:(CFErrorRef)error {

    BOOL isConnectionIssue = NO;

    NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);
    if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainPOSIX]) {

        switch (CFErrorGetCode(error)) {

            case ENETDOWN:      // Network is down (maybe even no connection on interface level)

            // Error cases which may occurs during socket lifecycle, when gateway uplink may go down and additional
            // network check should be performed
            case ENETUNREACH:   // Remote host can't be reached
            case EHOSTDOWN:     // Remote host is down
            case EHOSTUNREACH:  // Host can't be reached, because there is no route to it
            case ECONNREFUSED:  // Remote host doesn't want to accept connection

                isConnectionIssue = YES;
                break;
            default:
                break;
        }
    }
    else if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainCFNetwork]) {

        switch (CFErrorGetCode(error)) {

            case kCFHostErrorHostNotFound:

                isConnectionIssue = YES;
                break;
            default:
                break;
        }
    }


    return isConnectionIssue;
}

- (BOOL)isConnectionUplinkError:(CFErrorRef)error {

    BOOL isConnectionUplinkError = NO;

    NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);
    if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainPOSIX]) {

        switch (CFErrorGetCode(error)) {

            case ENETUNREACH:   // Remote host can't be reached
            case EHOSTDOWN:     // Remote host is down
            case EHOSTUNREACH:  // Host can't be reached, because there is no route to it
            case ECONNREFUSED:  // Remote host doesn't want to accept connection

                isConnectionUplinkError = YES;
                break;
            default:
                break;
        }
    }


    return isConnectionUplinkError;
}

- (BOOL)isSecurityTransportError:(CFErrorRef)error {
    
    BOOL isSecurityTransportError = NO;

    CFIndex errorCode = CFErrorGetCode(error);
    NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);

    if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainOSStatus]) {
#if __IPHONE_OS_VERSION_MIN_REQUIRED
        isSecurityTransportError = (errSSLUnexpectedRecord <= errorCode) && (errorCode <= errSSLProtocol);
#else
        isSecurityTransportError = (errSSLLast <= errorCode) && (errorCode <= errSSLProtocol);
#endif
    }
    else if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainCFNetwork]) {
        
        isSecurityTransportError = (kCFURLErrorCannotLoadFromNetwork <= errorCode) &&
                                   (errorCode <= kCFURLErrorSecureConnectionFailed);
    }
    
    
    return isSecurityTransportError;
}

- (BOOL)isInternalSecurityTransportError:(CFErrorRef)error {

    CFIndex code = CFErrorGetCode(error);
    
    return (code == errSSLInternal) || (code == errSSLClosedAbort);
}

- (BOOL)isTemporaryError:(CFErrorRef)error {
    
    BOOL isTemporaryError = NO;
    
    CFIndex errorCode = CFErrorGetCode(error);
    NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);
    
    if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainPOSIX]) {
        
        switch (errorCode) {
            case ETIMEDOUT:     // There is no activity on socket for some time
            case ENETRESET:     // Remote host crashed w/o sending 'close packet'
            case ECONNABORTED:  // Connection was aborted locally (by system or device)

            // Special cases when connection state was changed by remote server
            case ECONNRESET:    // Remote host sent 'close packet'

            case ENOBUFS:       // No space where data for sockets can be stored
            case ENOTCONN:      // Socket not connected or was disconnected

            case ESHUTDOWN:     // Socket was closed before new write attempt has been done
            case ENOENT:        // Rare error when system probably can't prepare sockets for further operation
            case EPIPE:         // Remote host went down or socket configuration not completed
            case EAGAIN:        // Requested resource not available
            case EISCONN:       // Socket already connected

                isTemporaryError = YES;
                break;
            default:
                break;
        }
    }
    else if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainCFNetwork]) {

        isTemporaryError = (kCFNetServiceErrorDNSServiceFailure <= errorCode) && (errorCode <= kCFNetServiceErrorUnknown);
        if (!isTemporaryError) {

            isTemporaryError = errorCode == kCFHostErrorUnknown || errorCode == kCFErrorHTTPConnectionLost;
        }
    }
    
    
    return isTemporaryError;
}

- (BOOL)isServerError:(CFErrorRef)error {
    
    BOOL isServerError = NO;
    
    CFIndex errorCode = CFErrorGetCode(error);
    NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);
    
    if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainPOSIX]) {
        
        switch (errorCode) {
            
            case ECONNRESET:    // Remote host sent 'close packet'
                
                isServerError = YES;
                break;
            default:
                break;
        }
    }
    
    
    return isServerError;
}


#pragma mark - Connection lifecycle management methods

- (BOOL)prepareStreams {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] PREPARE READ/WRITE STREAMS (STATE: %d)",
          self.name ? self.name : self, self.state);

    BOOL streamsPrepared = YES;

    // Check whether stream was prepared and configured before
    if (PNBitStrictIsOn(self.state, PNConnectionConfigured)) {

        NSString *state = @"";
        if ([self isConnecting]) {

            state = @"CONNECTING...";

        }
        else if ([self isConnected]) {

            state = @"CONNECTED.";
        }
        if ([self isResuming]) {

            state = @"RESUMING...";
        }
        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] STREAMS ALREADY CONFIGURATED%@ (STATE: %d)",
              self.name ? self.name : self, [state length] ? [NSString stringWithFormat:@" AND %@", state] : @".",
              self.state);
    }
    else {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CONFIGURATION STARTED (STATE: %d)",
              (self.name ? self.name : self), self.state);

        // Make sure that streams will be unable to operate (protection in case of state has been interrupted in some
        // way)
        [self destroyStreams];

        PNBitOff(&_state, PNConnectionDisconnecting);
        PNBitOn(&_state, PNConnectionDisconnected);


        // Define connection port which should be used by connection for further usage (depends on current connection
        // security policy)
        UInt32 targetPort = kPNOriginConnectionPort;
        if (self.configuration.shouldUseSecureConnection &&
            self.sslConfigurationLevel != PNConnectionSSLConfigurationInsecure) {

            targetPort = kPNOriginSSLConnectionPort;
        }

        // Retrieve connection proxy configuration
        [self retrieveSystemProxySettings];


        // Create stream pair on socket which is connected to specified remote host
        CFStreamCreatePairWithSocketToHost(CFAllocatorGetDefault(), (__bridge CFStringRef)(self.configuration.origin),
                                           targetPort, &_socketReadStream, &_socketWriteStream);

        [self configureReadStream:_socketReadStream];
        [self configureWriteStream:_socketWriteStream];

        // Check whether at least one of the streams was unable to complete configuration
        if (!PNBitIsOn(self.state, PNConnectionConfigured)) {

            PNLog(PNLogConnectionLayerErrorLevel, self, @"[CONNECTION::%@] CONFIGURATION FAILED (STATE: %d)",
                  self.name ? self.name : self, self.state);

            streamsPrepared = NO;

            [self destroyStreams];
            [self handleStreamSetupError];
        }
        else {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CONFIGURATION COMPLETED (STATE: %d)",
                  self.name ? self.name : self, self.state);
        }
    }


    return streamsPrepared;
}

- (BOOL)connect {
    
    PNBitOn(&_state, PNByUserRequest);
    
    
    return [self connectByInternalRequest];
}

- (BOOL)connectByInternalRequest {
    
    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] TRYING ESTABLISH CONNECTION... (BY USER REQUEST? %@)"
          "(STATE: %d)", self.name ? self.name : self, PNBitIsOn(self.state, PNByUserRequest) ? @"YES" : @"NO",
          self.state);

    __block BOOL isStreamOpened = NO;

    // Check whether connection was requested by user or not
    if (PNBitIsOn(self.state, PNByUserRequest)) {

        BOOL shouldDestroyStreams = [self isConnecting] || [self isReconnecting] || [self isDisconnecting] || [self isResuming];
        PNBitsOff(&_state, PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect,
                           BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNByInternalRequest, PNByServerRequest, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR);

        if (shouldDestroyStreams) {
            
            [self destroyStreams];
        }
    }

    PNBitOn(&_state, PNConnectionPrepareToConnect);


    // Ask delegate whether connection can be opened or not (in case if there is no internet connection or client was
    // disconnected by user request)
    if ([self.delegate connectionCanConnect:self]) {

        // Check whether client has been properly configured or not
        if (PNBitStrictIsOn(self.state, PNConnectionConfigured)) {

            PNBitOff(&_state, PNConnectionPrepareToConnect);

            BOOL isAbleToConnect = ![self isConnecting] && ![self isReconnecting] && ![self isConnected] &&
                                   ![self isDisconnecting] && ![self isResuming];

            if (isAbleToConnect) {

                // Mark that connection currently doesn't connected to the server
                PNBitOn(&_state, PNConnectionDisconnected);

                NSString *action = @"";

                // Check whether connection has been suspended before or not
                if (PNBitIsOn(self.state, PNConnectionSuspended)) {

                    // If connection is suspended, there is impossible that it may have any errors or ability to reconnect
                    PNBitsOff(&_state, PNConnectionCleanReconnection, PNConnectionErrorCleanAll, PNConnectionSuspending,
                                       BITS_LIST_TERMINATOR);
                    PNBitOn(&_state, PNConnectionResuming);

                    action = @"RESUMING";
                }
                else if (!PNBitStrictIsOn(self.state, PNConnectionConnected)) {

                    PNBitsOff(&_state, PNConnectionSuspending, PNConnectionSuspended, PNConnectionResuming,
                                       BITS_LIST_TERMINATOR);
                    action = [self shouldReconnect] ? @"RECONNECTING" : @"CONNECTING";
                }

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] %@... (STATE: %d)",
                      self.name ? self.name : self, action, self.state);

                isStreamOpened = YES;

                [self startTimeoutTimer];
                [self suspendWakeUpTimer];

                [self openReadStream:self.socketReadStream];
                [self openWriteStream:self.socketWriteStream];
            }
            else {

                void(^forciblyConnectionBlock)(void) = ^{

                    [self stopTimeoutTimer];
                    [self suspendWakeUpTimer];

                    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] LOOKS LIKE STREAMS IN INTERMEDIATE "
                          "STATE AND OUT OF SYNC. FORCIBLY CONNECTING... (STATE: %d)",
                          self.name ? self.name : self, self.state);

                    BOOL isConnectingByUserRequest = PNBitIsOn(self.state, PNByUserRequest);
                    PNBitOff(&_state, PNByUserRequest);

                    if (isConnectingByUserRequest) {

                        // Mark that disconnection has been called because of internal request
                        PNBitsOn(&_state, PNByInternalRequest, PNConnectionError, BITS_LIST_TERMINATOR);
                    }

                    // Forcibly close all connections
                    [self disconnectByInternalRequest];
                    isStreamOpened = isConnectingByUserRequest ? [self connect] : [self connectByInternalRequest];
                };

                if (![self isDisconnecting]) {

                    // Check whether tried to connect while already connected(-ing) or not. This condition take into
                    // account state of both streams at same time. If one of the stream has different state, this mean
                    // that connection probably in some wrong (messed) state.
                    BOOL isConnecting = [self isConnecting] || [self isReconnecting] || [self isConnected] || [self isResuming];

                    if (isConnecting) {

                        NSString *state = @"CONNECTING...";
                        if ([self isConnected]) {

                            state = @"CONNECTED.";
                        }
                        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] ALREADY %@ (STATE: %d)",
                              self.name ? self.name : self, state, self.state);
                    }
                    // Looks like tried to connect while was in some intermediate state (both streams in different
                    // states as for 'connected' or 'connecting'
                    else {

                        forciblyConnectionBlock();
                    }
                }
                else if ([self isDisconnecting]) {

                    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] TRIED TO CONNECT WHILE DISCONNETING"
                          ". WAIT FOR DISCONNECTION... (STATE: %d)", self.name ? self.name : self, self.state);

                    // Mark that client should try to connect back as soon as disconnection will be completed
                    PNBitOn(&_state, PNConnectionReconnectOnDisconnect);
                }
                else {

                    forciblyConnectionBlock();
                }
            }
        }
        // Looks like configuration not completed
        else {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] NOT CONFIGURED YET (STATE: %d)",
                  self.name ? self.name : self, self.state);

            // Try prepare connection's streams for future usage
            if ([self prepareStreams]) {

                isStreamOpened = [self connectByInternalRequest];
            }
        }
    }
    // Looks like connection can't be established at this moment. Launch wake up timer
    else {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CONNECTION IS IMPOSSIBLE AT THIS MOMENT. "
                "WAITING... (STATE: %d)", self.name ? self.name : self, self.state);

        PNBitOn(&_state, PNConnectionWakeUpTimer);

        [self resumeWakeUpTimer];
    }


    return isStreamOpened;
}

- (BOOL)canRetryConnection {
    
    return self.connectionRetryCount < kPNMaximumConnectionRetryCount;
}

- (void)retryConnection {
    
    self.connectionRetryCount++;
    
    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RETRY CONNECTION (%d / %d) (STATE: %d)",
          self.name ? self.name : self, self.connectionRetryCount, kPNMaximumConnectionRetryCount, self.state);
    
    // Check whether reconnection was issued because of SSL error or not
    if (self.sslConfigurationLevel == PNConnectionSSLConfigurationInsecure &&
        PNBitsIsOn(self.state, YES, PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR)) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RETRY CONNECTION BECAUSE OF INTERNAL SSL ERROR "
              "(STATE: %d)", self.name ? self.name : self, self.state);
    }
    // Check whether reconnection was issued because of socket temporary issues or not
    else if (PNBitsIsOn(self.state, YES, PNByInternalRequest, PNConnectionSocket, BITS_LIST_TERMINATOR)) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RETRY CONNECTION BECAUSE OF TEMPORARY ISSUES "
                "WITH SERVER OR SOCKET (STATE: %d)", self.name ? self.name : self, self.state);
    }
    
    [self reconnect];
}

- (void)reconnect {

    unsigned long oldStates = self.state;
    BOOL shouldReconnect = [self.delegate connectionShouldRestoreConnection:self];
    unsigned long newStates = self.state;

    BOOL stateChangedFromOutside = (oldStates != newStates && !PNBitIsOn(oldStates, PNByUserRequest) &&
                                    PNBitIsOn(newStates, PNByUserRequest));

    if (!stateChangedFromOutside) {

        if (shouldReconnect) {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] TRYING TO RECONNECT... (STATE: %d)",
                  self.name ? self.name : self, self.state);
        }
        else {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RECONNECT IS IMPOSSIBLE AT THIS MOMENT. "
                    "WAITING. (STATE: %d)",
                  self.name ? self.name : self, self.state);
        }

        // Ask delegate whether connection should initiate connection to remote host or not
        if (shouldReconnect) {

            BOOL isWaitingForReconnection = PNBitIsOn(self.state, PNConnectionReconnect);
            BOOL isReconnectingBecauseOfError = PNBitIsOn(self.state, PNConnectionError);
            PNBitsOff(&_state, PNConnectionCleanReconnection, PNConnectionError, BITS_LIST_TERMINATOR);

            // Marking that connection instance is reconnecting now and after last connection will be closed should
            // automatically renew connection
            PNBitOn(&_state, PNConnectionReconnect);
            [self destroyStreams];

            // Check whether 'reconnection' delayed request already has been issued or not
            if (!isWaitingForReconnection) {

                // Attempt to restore connection after small delay defined in 'static' section of this class
                __pn_desired_weak __typeof__ (self) weakSelf = self;
                NSTimeInterval delay = (NSTimeInterval) kPNConnectionRetryDelay;
                if (!isReconnectingBecauseOfError) {

                    delay = kPNConnectionRetryFastDelay;
                }
                dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC));
                dispatch_after(popTime, dispatch_get_main_queue(), ^{

                    if (PNBitIsOn(weakSelf.state, PNConnectionReconnect)) {

                        [self disconnectByInternalRequest];
                    }
                });
            }
        }
        else {

            PNBitOn(&_state, PNConnectionWakeUpTimer);

            [self resumeWakeUpTimer];
        }
    }
    else {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RECONNECT CANCELED. CONNECTION STATE HAS "
              "BEEN CHANGED FROMOUTSIDE. (STATE: %d)",
              self.name ? self.name : self, self.state);

        PNBitOn(&_state, PNConnectionWakeUpTimer);

        [self resumeWakeUpTimer];
    }
}

- (void)disconnect {
    
    PNBitOn(&_state, PNByUserRequest);
    self.connectionRetryCount = 0;
    
    [self disconnectByInternalRequest];
}

- (void)disconnectOnInternalRequest {

    PNBitsOff(&_state, PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR);
    PNBitsOff(&_state, PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect, BITS_LIST_TERMINATOR);
    PNBitsOff(&_state, PNByInternalRequest, PNByUserRequest, PNByServerRequest, BITS_LIST_TERMINATOR);
    PNBitsOff(&_state, PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR);
    PNBitsOff(&_state, PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR);


    [self disconnectByInternalRequest];
}

- (void)disconnectByInternalRequest {

    // Launch 'wake up' timer in case if disconnection was accident or some catch up logic failed because some tragic coincidence
    [self startWakeUpTimer];
    [self stopTimeoutTimer];

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] TRYING DISCONNECT... (BY USER REQUEST? %@)(STATE: %d)",
          self.name ? self.name : self, PNBitIsOn(self.state, PNByUserRequest) ? @"YES" : @"NO", self.state);

    PNBitsOff(&_state, PNConnectionConnecting, PNConnectionPrepareToConnect, PNConnectionResuming, BITS_LIST_TERMINATOR);

    // Check whether it was requested to perform disconnection on user request or not
    if (PNBitIsOn(self.state, PNByUserRequest)) {

        PNBitsOff(&_state, PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNByInternalRequest, PNByServerRequest, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR);
    }

    // Clean up cached data
    [self unscheduleRequestsExecution];
    self.proxySettings = nil;

    [self disconnectReadStream:_socketReadStream];
    [self disconnectWriteStream:_socketWriteStream];
}

- (void)destroyStreams {

    BOOL isAnyOfStreamsStillValid = _socketReadStream != NULL || _socketWriteStream != NULL;
    if (isAnyOfStreamsStillValid) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] DESTROYING STREAMS... (STATE: %d)",
              self.name ? self.name : self, self.state);
    }

    // Clean up cached data
    [self unscheduleRequestsExecution];
    self.proxySettings = nil;

    BOOL isConfiguring = PNBitIsOn(self.state, PNConnectionConfiguring);
    BOOL isReadStreamErrorSet = PNBitIsOn(self.state, PNReadStreamError);
    BOOL isWriteStreamErrorSet = PNBitIsOn(self.state, PNWriteStreamError);

    [self destroyReadStream:_socketReadStream];
    [self destroyWriteStream:_socketWriteStream];

    PNBitsOff(&_state, PNReadStreamCleanAll, PNWriteStreamCleanAll, BITS_LIST_TERMINATOR);
    PNBitOn(&_state, PNConnectionDisconnected);

    if (isConfiguring) {

        PNBitOn(&_state, PNConnectionConfiguring);
    }

    if (isReadStreamErrorSet || isWriteStreamErrorSet) {

        PNBitOn(&_state, PNConnectionError);
    }

    if (isAnyOfStreamsStillValid) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] READ AND WRITE STREAMS DESTROYED (STATE: %d)",
              self.name ? self.name : self, self.state);
    }
}

- (void)suspend {

    // Check whether connection established to the remote host or not
    if ([self isConnected]) {

        // Check whether connection can be suspended or not
        if (![self isSuspending] && ![self isSuspended]) {

            PNBitsOff(&_state, PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR);
            PNBitsOff(&_state, PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect, BITS_LIST_TERMINATOR);
            PNBitsOff(&_state, PNByInternalRequest, PNByServerRequest, BITS_LIST_TERMINATOR);
            PNBitsOff(&_state, PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR);
            PNBitsOff(&_state, PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR);

            PNBitOn(&_state, PNConnectionSuspending);
            [self disconnectByInternalRequest];
        }
        // Looks like connection already suspended
        else if ([self isSuspended]){

            [self.delegate connectionDidSuspend:self];
        }
    }
    else {

        [self disconnectOnInternalRequest];
        PNBitsOn(&_state, PNConnectionDisconnected, PNConnectionSuspended, BITS_LIST_TERMINATOR);

        [self.delegate connectionDidSuspend:self];
    }

    [self suspendWakeUpTimer];
    [self stopTimeoutTimer];
}

- (BOOL)isSuspending {

    return PNBitIsOn(self.state, PNConnectionSuspending);
}

- (BOOL)isSuspended {

    return PNBitsIsOn(self.state, YES, PNConnectionDisconnected, PNConnectionSuspended, BITS_LIST_TERMINATOR);
}

- (void)resume {

    // Check whether connection suspended at this moment or not
    if (![self isConnected] && [self isSuspended] && ![self isResuming]) {

        // In case if because of some reasons connection can't be established we should launch 'wake up' timer to
        // help fix connection state when it will be possible
        if(![self connectByInternalRequest]) {

            PNBitOn(&_state, PNConnectionWakeUpTimer);

            [self resumeWakeUpTimer];
        }
    }
    else if ([self isConnected]) {

        [self.delegate connectionDidResume:self];
    }
}

- (BOOL)isResuming {

    return PNBitsIsOn(self.state, YES, PNConnectionConnecting, PNConnectionResuming, BITS_LIST_TERMINATOR);
}


#pragma mark - Read stream lifecycle management methods

- (void)configureReadStream:(CFReadStreamRef)readStream {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] CONFIGURING... (STATE: %d)",
          self.name ? self.name : self, self.state);

    PNBitOff(&_state, PNReadStreamCleanConfiguration);
    PNBitOn(&_state, PNReadStreamConfiguring);

    CFOptionFlags options = (kCFStreamEventOpenCompleted | kCFStreamEventHasBytesAvailable |
                             kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered);
    CFStreamClientContext client = [self streamClientContext];

    // Configuring connection channel instance as client for read stream with described set of handling events
    BOOL isStreamReady = CFReadStreamSetClient(readStream, options, readStreamCallback, &client);
    if (isStreamReady) {

        isStreamReady = CFReadStreamSetProperty(readStream, kCFStreamPropertyShouldCloseNativeSocket, kCFBooleanTrue);
    }

    if (self.streamSecuritySettings != NULL && isStreamReady) {

        // Configuring stream to establish SSL connection
        isStreamReady = CFReadStreamSetProperty(readStream,
                                                (__bridge CFStringRef)NSStreamSocketSecurityLevelKey,
                                                (__bridge CFStringRef)NSStreamSocketSecurityLevelSSLv3);

        if (isStreamReady) {

            // Specify connection security options
            isStreamReady = CFReadStreamSetProperty(readStream, kCFStreamPropertySSLSettings, self.streamSecuritySettings);
        }
    }


    if (isStreamReady) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] CONFIGURATION COMPLETED (STATE: %d)",
              self.name ? self.name : self, self.state);

        PNBitOff(&_state, PNReadStreamConfiguring);
        PNBitOn(&_state, PNReadStreamConfigured);

        // Schedule read stream on current run-loop
        CFReadStreamScheduleWithRunLoop(readStream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);
    }
    else {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] CONFIGURATION FAILED (STATE: %d)",
              self.name ? self.name : self, self.state);

        PNBitOn(&_state, PNReadStreamError);
    }
}

- (void)openReadStream:(CFReadStreamRef)readStream {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] SCHEDULING OPENING... (STATE: %d)",
          self.name ? self.name : self, self.state);

    PNBitOff(&_state, PNReadStreamCleanConnection);
    PNBitOn(&_state, PNReadStreamConnecting);

    if (!CFReadStreamOpen(readStream)) {

        CFErrorRef error = CFReadStreamCopyError(readStream);
        if (error && CFErrorGetCode(error) != 0) {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] FAILED TO OPEN (STATE: %d)",
                  self.name ? self.name : self, self.state);

            PNBitOn(&_state, PNReadStreamError);
            [self handleStreamError:error];
        }
        else {

            CFRunLoopRun();
        }

        PNCFRelease(&error);
    }
    else {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] OPEN IS SCHEDULED (STATE: %d)",
              self.name ? self.name : self, self.state);
    }
}

- (void)disconnectReadStream:(CFReadStreamRef)readStream {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] DISCONNECTING... (STATE: %d)",
          self.name ? self.name : self, self.state);

    PNBitsOff(&_state, PNReadStreamConnecting, PNReadStreamCleanDisconnection, BITS_LIST_TERMINATOR);
    PNBitOn(&_state, PNReadStreamDisconnecting);

    // Check whether there is some data received from server and try to parse it
    if ([_retrievedData length] > 0 || [_temporaryRetrievedData length] > 0) {

        [self processResponse];
    }

    // Destroying input buffer
    _retrievedData = nil;
    _temporaryRetrievedData = nil;

    BOOL streamHasError = PNBitIsOn(self.state, PNReadStreamError);
    [self destroyReadStream:readStream];

    if (streamHasError) {

        PNBitOn(&_state, PNReadStreamError);
    }
    [self handleStreamClose];
}

- (void)destroyReadStream:(CFReadStreamRef)readStream {

    BOOL isStreamExists = readStream != NULL;
    if (isStreamExists) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] DESTROYING... (STATE: %d)",
              self.name ? self.name : self, self.state);
    }

    if (isStreamExists) {

        CFReadStreamSetClient(readStream, kCFStreamEventNone, NULL, NULL);
        CFReadStreamClose(readStream);
        PNCFRelease(&readStream);
        self.socketReadStream = NULL;
    }

    PNBitOff(&_state, PNReadStreamCleanConfiguration);

    if (isStreamExists) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] DESTROYED (STATE: %d)",
              self.name ? self.name : self, self.state);
    }
}


#pragma mark - Read stream lifecycle data processing methods

- (void)readStreamContent {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] READING ARRIVED DATA... (STATE: %d)",
          self.name ? self.name : self, self.state);

    // Check whether data available right now or not (this is non-blocking request)
    if (CFReadStreamHasBytesAvailable(self.socketReadStream)) {

        // Read raw data from stream
        UInt8 buffer[kPNStreamBufferSize];
        CFIndex readedBytesCount = CFReadStreamRead(self.socketReadStream, buffer, kPNStreamBufferSize);

        // Checking whether client was able to read out some data from stream or not
        if (readedBytesCount > 0) {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] READED %d BYTES (STATE: %d)",
                  self.name ? self.name : self, readedBytesCount, self.state);


            // Check whether debugging options is enabled to show received response or not
            if (PNLoggingEnabledForLevel(PNLogConnectionLayerHTTPLoggingLevel) || PNHTTPDumpOutputToFileEnabled()) {

                NSData *tempData = [NSData dataWithBytes:buffer length:(NSUInteger)readedBytesCount];

                if (PNLoggingEnabledForLevel(PNLogConnectionLayerHTTPLoggingLevel)) {

                    NSString *responseString = [[NSString alloc] initWithData:tempData encoding:NSUTF8StringEncoding];
                    if (!responseString) {

                        responseString = [[NSString alloc] initWithData:tempData encoding:NSASCIIStringEncoding];
                    }
                    if (!responseString) {

                        responseString = @"Can't striongify response. Try check response dump on file system (if enabled)";
                    }

                    PNLog(PNLogConnectionLayerHTTPLoggingLevel, self, @"[CONNECTION::%@::READ] RESPONSE: %@",
                                          self.name ? self.name : self, responseString);
                }

                PNHTTPDumpOutputToFile(tempData);
            }

            // Check whether working on data deserialization or not
            if (self.deserializer.isDeserializing) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] DESERIALIZED IS BUSY. WRITTING "
                        "INTO TEMPORARY STORAGE (STATE: %d)",
                      self.name ? self.name : self, readedBytesCount, self.state);

                // Temporary store data in object
                [self.temporaryRetrievedData appendBytes:buffer length:(NSUInteger)readedBytesCount];
            }
            else {

                // Store fetched data
                [self.retrievedData appendBytes:buffer length:(NSUInteger)readedBytesCount];
                [self processResponse];
            }
        }
        // Looks like there is no data or error occurred while tried to read out stream content
        else if (readedBytesCount < 0) {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] READ ERROR (STATE: %d)",
                  self.name ? self.name : self, self.state);

            CFErrorRef error = CFReadStreamCopyError(self.socketReadStream);
            PNBitOn(&_state, PNReadStreamError);
            [self handleStreamError:error];

            PNCFRelease(&error);
        }
    }
}

- (void)processResponse {

    // Retrieve response objects from server response
    NSArray *responses = [self.deserializer parseResponseData:self.retrievedData];

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] {%d} RESPONSE MESSAGES PROCESSED (STATE: %d)",
          self.name ? self.name : self, [responses count], self.state);

    if ([responses count] > 0) {

        [responses enumerateObjectsUsingBlock:^(id response, NSUInteger responseIdx, BOOL *responseEnumeratorStop) {

            // Check whether server reported that connection will be closed after this portion of data
            if (!PNBitIsOn(self.state, PNByServerRequest) && [(id<PNResponseProtocol>)response isLastResponseOnConnection]) {

                PNBitsOn(&_state, PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR);

                // Inform delegate that connection will be closed soon by server request
                [self.delegate connection:self willDisconnectByServerRequestFromHost:self.configuration.origin];
            }

            // Notify delegate about new event arrival
            [self.delegate connection:self didReceiveResponse:response];
        }];
    }


    // Check whether connection stored some response in temporary storage or not
    if ([_temporaryRetrievedData length] > 0) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::READ] THERE IS %d BYTES IN TEMPORARY BUFFER. "
                "PROCESS... (STATE: %d)",
              self.name ? self.name : self, [_temporaryRetrievedData length], self.state);

        [self.retrievedData appendData:_temporaryRetrievedData];
        _temporaryRetrievedData = nil;

        // Try to process retrieved data once more (maybe some full response arrived from remote server)
        [self processResponse];
    }
    else {

        // Check whether client is still connected and there is request from server side to close connection.
        // Connection will be restored after full disconnection
        if ([self isConnected] && ![self isReconnecting] && ![self isDisconnecting] &&
            PNBitIsOn(self.state, PNByServerRequest)) {

            [self disconnectByInternalRequest];
        }
    }
}


#pragma mark - Write stream lifecycle management methods


- (void)configureWriteStream:(CFWriteStreamRef)writeStream {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] CONFIGURING... (STATE: %d)",
          self.name ? self.name : self, self.state);

    PNBitOff(&_state, PNWriteStreamCleanConfiguration);
    PNBitOn(&_state, PNWriteStreamConfiguring);

    CFOptionFlags options = (kCFStreamEventOpenCompleted | kCFStreamEventCanAcceptBytes |
                             kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered);
    CFStreamClientContext client = [self streamClientContext];

    // Configuring connection channel instance as client for write stream with described set of handling events
    BOOL isStreamReady = CFWriteStreamSetClient(writeStream, options, writeStreamCallback, &client);
    if (isStreamReady) {
        
        isStreamReady = CFWriteStreamSetProperty(writeStream, kCFStreamPropertyShouldCloseNativeSocket, kCFBooleanTrue);
    }


    if (isStreamReady) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] CONFIGURATION COMPLETED (STATE: %d)",
              self.name ? self.name : self, self.state);

        PNBitOff(&_state, PNWriteStreamConfiguring);
        PNBitOn(&_state, PNWriteStreamConfigured);

        // Schedule write stream on current run-loop
        CFWriteStreamScheduleWithRunLoop(writeStream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);
    }
    else {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] CONFIGURATION FAILED (STATE: %d)",
              self.name ? self.name : self, self.state);

        PNBitOn(&_state, PNWriteStreamError);
    }
}

- (void)openWriteStream:(CFWriteStreamRef)writeStream {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] SCHEDULING OPENING... (STATE: %d)",
          self.name ? self.name : self, self.state);

    PNBitOff(&_state, PNWriteStreamCleanConnection);
    PNBitOn(&_state, PNWriteStreamConnecting);

    if (!CFWriteStreamOpen(writeStream)) {

        CFErrorRef error = CFWriteStreamCopyError(writeStream);
        if (error && CFErrorGetCode(error) != 0) {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] FAILED TO OPEN (STATE: %d)",
                  self.name ? self.name : self, self.state);

            PNBitOn(&_state, PNWriteStreamError);
            [self handleStreamError:error];
        }
        else {

            CFRunLoopRun();
        }

        PNCFRelease(&error);
    }
    else {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] OPEN IS SCHEDULED (STATE: %d)",
              self.name ? self.name : self, self.state);
    }
}

- (void)disconnectWriteStream:(CFWriteStreamRef)writeStream {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] DISCONNECTING... (STATE: %d)",
          self.name ? self.name : self, self.state);

    PNBitsOff(&_state, PNWriteStreamConnecting, PNWriteStreamCleanDisconnection, BITS_LIST_TERMINATOR);
    PNBitOn(&_state, PNWriteStreamDisconnecting);
    self.writeStreamCanHandleData = NO;

    // Handle canceled request (if there was such)
    [self handleRequestSendingCancelation];

    BOOL streamHasError = PNBitIsOn(self.state, PNWriteStreamError);
    [self destroyWriteStream:writeStream];

    if (streamHasError) {

        PNBitOn(&_state, PNWriteStreamError);
    }
    [self handleStreamClose];
}

- (void)destroyWriteStream:(CFWriteStreamRef)writeStream {

    BOOL isStreamExists = writeStream != NULL;
    if (isStreamExists) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] DESTROYING... (STATE: %d)",
              self.name ? self.name : self, self.state);
    }

    if (isStreamExists) {

        CFWriteStreamSetClient(writeStream, kCFStreamEventNone, NULL, NULL);
        CFWriteStreamClose(writeStream);
        PNCFRelease(&writeStream);
        self.socketWriteStream = NULL;
    }

    PNBitOff(&_state, PNWriteStreamCleanConfiguration);

    if (isStreamExists) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] DESTROYED (STATE: %d)",
              self.name ? self.name : self, self.state);
    }
}


#pragma mark - Write stream buffer management methods

- (void)prepareNextRequestPacket {

    // Ensure that connection is able to send next portion of data which will be prepared
    BOOL shouldPrepareData = [self isConnected] && ![self isReconnecting] && ![self isDisconnecting] &&
                             !PNBitsIsOn(self.state, YES, PNConnectionDisconnect, PNByServerRequest,
                                                          BITS_LIST_TERMINATOR) && ![self isResuming];

    if (shouldPrepareData) {

        // Check whether data source can provide some data right after connection is established or not
        if ([self.dataSource hasDataForConnection:self]) {

            NSString *requestIdentifier = [self.dataSource nextRequestIdentifierForConnection:self];
            self.writeBuffer = [self.dataSource connection:self requestDataForIdentifier:requestIdentifier];
        }
    }
}

- (void)writeBufferContent {

    BOOL(^writeStreamIsAbleToSend)(void) = ^{

        return (BOOL)([self isConnected] && ![self isReconnecting] && ![self isDisconnecting] &&
                      !PNBitsIsOn(self.state, YES, PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR) &&
                      self.isWriteStreamCanHandleData && ![self isResuming]);
    };

    // Check whether there is connection which can be used to write data
    if (writeStreamIsAbleToSend()) {

        if (self.writeBuffer != nil) {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] WRITE BUFFER CONTENT (STATE: %d)",
                  self.name ? self.name : self, self.state);

            PNBitOff(&_state, PNWriteStreamError);

            if (self.writeBuffer.length > 0) {

                PNBitOff(&_state, PNWriteStreamError);
                PNBitOn(&_state, PNSendingData);

                // Check whether connection can pull some data
                // from write buffer or not
                BOOL isWriteBufferIsEmpty = ![self.writeBuffer hasData];
                if (!isWriteBufferIsEmpty) {

                    if (self.isWriteStreamCanHandleData) {

                        // Check whether we just started request processing or not
                        if (self.writeBuffer.offset == 0) {

                            // Mark that buffer content sending was initiated
                            self.writeBuffer.sendingBytes = YES;

                            // Notify data source that we started request processing
                            [self.dataSource connection:self processingRequestWithIdentifier:self.writeBuffer.requestIdentifier];
                        }

                        if (writeStreamIsAbleToSend() && self.writeBuffer != nil) {
                            
                            // Try write data into write stream
                            CFIndex bytesWritten = CFWriteStreamWrite(self.socketWriteStream, [self.writeBuffer buffer],
                                                                      [self.writeBuffer bufferLength]);

                            // Check whether error occurred while tried to process request
                            if (bytesWritten < 0) {

                                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] WRITE ERROR (STATE: %d)",
                                      self.name ? self.name : self, self.state);

                                // Mark that buffer content is not processed at this moment
                                self.writeBuffer.sendingBytes = NO;
                                self.writeStreamCanHandleData = NO;

                                // Retrieve error which occurred while tried to write buffer into socket
                                CFErrorRef writeError = CFWriteStreamCopyError(self.socketWriteStream);
                                PNBitOn(&_state, PNWriteStreamError);

                                [self handleRequestProcessingError:writeError];

                                PNCFRelease(&writeError);
                                isWriteBufferIsEmpty = YES;
                            }
                            // Check whether socket was able to transfer whole write buffer at once or not
                            else if (bytesWritten == self.writeBuffer.length) {

                                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] WRITTEN WHOLE "
                                        "REQUEST BODY (%d/%d BYTES)(STATE: %d)",
                                      self.name ? self.name : self, bytesWritten, self.writeBuffer.length, self.state);

                                // Mark that buffer content is not processed at this moment
                                self.writeBuffer.sendingBytes = NO;

                                // Set readout offset to buffer content length (there is no more data to send)
                                self.writeBuffer.offset = self.writeBuffer.length;

                                isWriteBufferIsEmpty = YES;
                            }
                            else {

                                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] WRITTEN PART OF "
                                        "REQUEST BODY (%d/%d BYTES)(STATE: %d)",
                                      self.name ? self.name : self, (self.writeBuffer.offset + bytesWritten), self.writeBuffer.length, self.state);

                                self.writeStreamCanHandleData = NO;

                                // Increase buffer readout offset
                                self.writeBuffer.offset = (self.writeBuffer.offset + bytesWritten);
                                if (self.writeBuffer.offset == self.writeBuffer.length) {

                                    self.writeStreamCanHandleData = YES;
                                    isWriteBufferIsEmpty = YES;
                                }
                            }
                        }
                        else {

                            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] WRITE CANCELED (STATE: %d)",
                                  self.name ? self.name : self, self.state);
                        }
                    }
                }


                if (isWriteBufferIsEmpty) {

                    PNBitOff(&_state, PNSendingData);

                    // Retrieving reference on request's identifier who's body has been sent
                    NSString *identifier = self.writeBuffer.requestIdentifier;
                    self.writeBuffer = nil;

                    [self.dataSource connection:self didSendRequestWithIdentifier:identifier];


                    // Check whether should try to send next request or not
                    if (PNBitIsOn(self.state, PNConnectionProcessingRequests)) {

                        if (writeStreamIsAbleToSend()) {

                            [self scheduleNextRequestExecution];
                        }
                        else if (PNBitsIsOn(self.state, YES, PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR)) {

                            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] CAN'T PROCESS NEXT REQUEST "
                                    "BECAUSE CONNECTION WILL BE CLOSED SOON (STATE: %d)",
                                  self.name ? self.name : self, self.state);
                        }
                    }
                }
            }
            // Looks like because of some reasons there is no new data
            else {

                if (PNBitIsOn(self.state, PNConnectionProcessingRequests)) {

                    if (writeStreamIsAbleToSend()) {

                        [self scheduleNextRequestExecution];
                    }
                    else if(PNBitsIsOn(self.state, YES, PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR)) {

                        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] CAN'T PROCESS NEXT REQUEST "
                              "BECAUSE CONNECTION WILL BE CLOSED SOON (STATE: %d)",
                              self.name ? self.name : self, self.state);
                    }
                }
            }
        }
        else {

            [self scheduleNextRequestExecution];
        }
    }
    else if (PNBitStrictIsOn(self.state, PNConnectionConnected)) {

        if (PNBitsIsOn(self.state, YES, PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR)) {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] CAN'T PROCESS NEXT REQUEST "
                  "BECAUSE CONNECTION WILL BE CLOSED SOON (STATE: %d)",
                  self.name ? self.name : self, self.state);
        }
        else {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@::WRITE] NOTHING TO WRITE (STATE: %d)",
                  self.name ? self.name : self, self.state);
        }
    }
}


#pragma mark - Handler methods

- (void)handleStreamConnection {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] HANDLE STREAM CONNECTION OPENED (STATE: %d)",
          self.name ? self.name : self, self.state);

    // Ensure that both read and write streams are connected before notify
    // delegate about successful connection
    if (PNBitStrictIsOn(self.state, PNConnectionConnecting) && PNBitStrictIsOn(self.state, PNConnectionConnected)) {

        BOOL retriedConnection = self.connectionRetryCount != 0;

        // Resetting some cached data
        self.configurationRetryCount = 0;
        self.connectionRetryCount = 0;

        // Terminate wake up timer
        [self stopWakeUpTimer];
        [self stopTimeoutTimer];

        BOOL isRestoredAfterServerClosed = PNBitsIsOn(self.state, YES, PNConnectionDisconnect, PNByServerRequest,
                                                                       BITS_LIST_TERMINATOR);
        BOOL isConnectionReset = PNBitsIsOn(self.state, YES, PNConnectionError, PNByInternalRequest, BITS_LIST_TERMINATOR);
        BOOL isReconnectedByWakeUpTimer = PNBitsIsOn(self.state, YES, PNByInternalRequest, PNConnectionWakeUpTimer,
                                                                      BITS_LIST_TERMINATOR);
        BOOL isReconnectedBySSL = PNBitsIsOn(self.state, YES, PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR);
        BOOL isReconnectedBySocket = PNBitsIsOn(self.state, YES, PNByInternalRequest, PNConnectionSocket,
                                                                 BITS_LIST_TERMINATOR);
        BOOL connectedAfterError = PNBitIsOn(self.state, PNConnectionError);
        BOOL isByUserRequest = PNBitIsOn(self.state, PNByUserRequest);
        BOOL isReconnecting = [self isReconnecting];
        BOOL isResuming = [self isResuming];

        PNBitsOff(&_state, PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNByInternalRequest, PNByUserRequest, PNByServerRequest, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR);

        if (retriedConnection) {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CONNECTED ON RETRY (STATE: %d)",
                  self.name ? self.name : self, self.state);
        }

        // Check whether connection has been established as result of user calling '-connect' method or not
        if (isByUserRequest) {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CONNECTED (BY USER REQUEST? %@)(STATE: %d)",
                  self.name ? self.name : self, isByUserRequest ? @"YES" : @"NO", self.state);

            // Notify delegate that initial connection is established
            [self.delegate connection:self didConnectToHost:self.configuration.origin];
        }
        else {

            // Check whether connection is resuming after it was suspended or not
            if (isResuming) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RESUMED (STATE: %d)",
                      self.name ? self.name : self, self.state);

                [self.delegate connectionDidResume:self];
            }
            // Check whether connection has been restored after server closed it (for example when server doesn't
            // support 'keep-alive' connection type
            else if (isRestoredAfterServerClosed) {

                // Inform delegate that connection finally recovered after it has been close by remote server
                [self.delegate  connection:self didRestoreAfterServerCloseConnectionToHost:self.configuration.origin];
            }
            // Check whether connection has been forcibly reset after found out that it is in wrong state
            else if (isConnectionReset) {

                // Inform delegate that connection has been completely reset and ready to work
                [self.delegate connectionDidReset:self];
            }
            // Check whether connection has been restored after some error occurred on streams
            else if (connectedAfterError) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RECONNECTED AFTER ERROR (STATE: %d)",
                      self.name ? self.name : self, self.state);

                [self.delegate connection:self didReconnectToHostAfterError:self.configuration.origin];
            }
            // Check whether connection has been reconnected by request from 'wake up' timer/SSL/sockets
            else if (isReconnectedByWakeUpTimer || isReconnectedBySSL || isReconnectedBySocket) {

                NSString *eventSource = @"WAKE UP TIMER";
                if (isReconnectedBySSL) {

                    eventSource = @"SSL ERROR";
                }
                else if (isReconnectedBySocket) {

                    eventSource = @"NETWORK FAILURE OR SERVER TEMPORARY ISSUES";
                }

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RECONNECTED BECAUSE OF %@ (STATE: %d)",
                      self.name ? self.name : self, eventSource, self.state);

                [self.delegate connection:self didReconnectToHostAfterError:self.configuration.origin];
            }
            // Check whether connection has been reconnected by request or not
            else if (isReconnecting) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RECONNECTED (BY USER REQUEST? %@)"
                      "(STATE: %d)",
                      self.name ? self.name : self, isByUserRequest ? @"YES" : @"NO", self.state);

                [self.delegate connection:self didReconnectToHost:self.configuration.origin];
            }
            else {

                [self.delegate connection:self didConnectToHost:self.configuration.origin];
            }
        }

        // Check whether channel should process requests from upper layers or not
        if (PNBitIsOn(self.state, PNConnectionProcessingRequests)) {

            [self scheduleNextRequestExecution];
        }
    }
}

- (void)handleStreamClose {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] HANDLE STREAM CONNECTION CLOSED (STATE: %d)",
          self.name ? self.name : self, self.state);

    // Ensure that both read and write streams reset before notify delegate about connection close event
    if (PNBitStrictIsOn(self.state, PNConnectionDisconnecting) && !PNBitStrictIsOn(self.state, PNConnectionDisconnected)) {

        BOOL retriedConnection = self.connectionRetryCount != 0;

        // Resetting some cached data
        self.configurationRetryCount = 0;

        [self stopTimeoutTimer];


        BOOL isDisconnectedByServerRequest = PNBitsIsOn(self.state, YES, PNConnectionDisconnect, PNByServerRequest,
                                                                         BITS_LIST_TERMINATOR);
        BOOL isDisconnectedOnReset = PNBitsIsOn(self.state, YES, PNConnectionError, PNByInternalRequest,
                                                                 BITS_LIST_TERMINATOR);
        BOOL isDisconnectedByWakeUpTimer = PNBitsIsOn(self.state, YES, PNByInternalRequest, PNConnectionWakeUpTimer,
                                                      BITS_LIST_TERMINATOR);
        BOOL isDisconnectedBySSL = PNBitsIsOn(self.state, YES, PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR);
        BOOL isDisconnectedBySocket = PNBitsIsOn(self.state, YES, PNByInternalRequest, PNConnectionSocket,
                                                                  BITS_LIST_TERMINATOR);
        BOOL isDisconnectedOnError = PNBitIsOn(self.state, PNConnectionError);
        BOOL isByUserRequest = PNBitIsOn(self.state, PNByUserRequest);
        BOOL shouldConnectOnDisconnect = PNBitIsOn(self.state, PNConnectionReconnectOnDisconnect);
        BOOL isReconnecting = [self shouldReconnect];
        BOOL isSuspending = [self isSuspending];

        PNBitsOff(&_state, PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionReconnect, PNConnectionReconnectOnDisconnect, PNConnectionDisconnect, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNByInternalRequest, PNByUserRequest, PNByServerRequest, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionCleanReconnection, PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNConnectionResuming, PNConnectionSuspending, PNConnectionSuspended, BITS_LIST_TERMINATOR);
        PNBitsOff(&_state, PNReadStreamCleanAll, PNWriteStreamCleanAll, BITS_LIST_TERMINATOR);
        PNBitOn(&_state, PNConnectionDisconnected);

        if (isDisconnectedOnError) {

            PNBitOn(&_state, PNConnectionError);
        }

        void(^reconnectOnErrorBlock)(void) = ^{

            // Attempt to restore connection after small delay defined in 'static' section of this class
            __pn_desired_weak __typeof__ (self) weakSelf = self;
            dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(kPNConnectionRetryDelay * NSEC_PER_SEC));
            dispatch_after(popTime, dispatch_get_main_queue(), ^{

                // Check whether connection is still in bad state before issue connection
                if (PNBitIsOn(weakSelf.state, PNConnectionError)) {

                    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RECONNECTING ON ERROR... "
                            "(STATE: %d)",
                          self.name ? self.name : self, self.state);

                    [weakSelf resumeWakeUpTimer];
                    [self stopTimeoutTimer];

                    if (isByUserRequest) {

                        PNLog(PNLogConnectionLayerInfoLevel,
                              weakSelf,
                              @"[CONNECTION::%@] CONNECT FROM THE NAME OF THE USER "
                                      "BECAUSE INITIAL CONNECT BEFORE ERROR HAS BEEN DONE BY HIM (STATE: %d)",
                              weakSelf.name ? weakSelf.name : weakSelf,
                              weakSelf.state);

                        [weakSelf connect];
                    }
                    else {

                        [weakSelf connectByInternalRequest];
                    }
                }
            });
        };

        if (retriedConnection) {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] DISCONNECTED ON RETRY (STATE: %d)",
                  self.name ? self.name : self, self.state);
        }

        if (shouldConnectOnDisconnect || isDisconnectedByServerRequest || isDisconnectedOnReset ||
            isDisconnectedByWakeUpTimer || isDisconnectedBySSL || isDisconnectedBySocket || isReconnecting ||
            retriedConnection) {

            unsigned long flagsToEnableBack = 0;

            // Check whether there was attempt to connect while was connection was in disconnection state
            if (shouldConnectOnDisconnect) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CATCH UP PREVIOUS REQUEST TO CONNECT "
                      "(STATE: %d)", self.name ? self.name : self, self.state);
            }
            else if (isDisconnectedByServerRequest) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] EXPECTED DISCONNECTION. RECONNECTING..."
                      " (STATE: %d)", self.name ? self.name : self, self.state);

                PNBitsOn(&flagsToEnableBack, PNByServerRequest, PNConnectionDisconnect, BITS_LIST_TERMINATOR);
                PNBitOn(&_state, flagsToEnableBack);

                // Notify delegate that connection has been terminated by server request
                [self.delegate connection:self didDisconnectByServerRequestFromHost:self.configuration.origin];
            }
            else if (isDisconnectedOnReset) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] DISCONNECTED ON CONNECTION RESET. "
                      "RECONNECTING... (STATE: %d)", self.name ? self.name : self, self.state);

                PNBitsOn(&flagsToEnableBack, PNByInternalRequest, PNConnectionError, BITS_LIST_TERMINATOR);
            }
            else if (isDisconnectedByWakeUpTimer || isDisconnectedBySSL || isDisconnectedBySocket) {

                NSString *eventSource = @"WAKE UP TIMER";
                PNBitsOn(&flagsToEnableBack, PNByInternalRequest, PNConnectionWakeUpTimer, BITS_LIST_TERMINATOR);

                if (isDisconnectedBySSL) {

                    PNBitClear(&flagsToEnableBack);
                    PNBitsOn(&flagsToEnableBack, PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR);

                    eventSource = @"SSL ERROR";
                }
                else if (isDisconnectedBySocket) {

                    PNBitClear(&flagsToEnableBack);
                    PNBitsOn(&flagsToEnableBack, PNByInternalRequest, PNConnectionSocket, BITS_LIST_TERMINATOR);

                    eventSource = @"NETWORK FAILURE OR SERVER TEMPORARY ISSUES";
                }

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RECONNECTING BECAUSE OF %@ (STATE: %d)",
                      self.name ? self.name : self, eventSource, self.state);

                PNBitOn(&_state, flagsToEnableBack);

                // Notify delegate that connection will be restored because of reconnection request
                [self.delegate connection:self willReconnectToHostAfterError:self.configuration.origin];
            }
            else if (isReconnecting) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RECONNECTING... (STATE: %d)",
                      self.name ? self.name : self, self.state);

                PNBitOn(&flagsToEnableBack, PNConnectionReconnection);

                // Notify delegate that connection will be restored because of reconnection request
                [self.delegate connection:self willReconnectToHost:self.configuration.origin];
            }
            else if (retriedConnection) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] RETRYING CONNECTION... (STATE: %d)",
                      self.name ? self.name : self, self.state);
            }

            PNBitOn(&_state, PNConnectionWakeUpTimer);
            [self resumeWakeUpTimer];
            if (isByUserRequest) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CONNECT FROM THE NAME OF THE USER "
                      "BECAUSE INITIAL CONNECT BEFORE ERROR HAS BEEN DONE BY HIM (STATE: %d)",
                      self.name ? self.name : self, self.state);

                [self connect];
            }
            else {

                [self connectByInternalRequest];
            }

            // Restore error state flags because of which connection should be restored back
            PNBitOn(&_state, flagsToEnableBack);
        }
        // Check whether connection has been closed by user request or not
        else if (isByUserRequest) {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CONNECTION CLOSED BY USER REQUEST (STATE: %d)",
                  self.name ? self.name : self, self.state);

            if (!isDisconnectedOnError) {

                self.connectionRetryCount = 0;

                PNBitOn(&_state, PNConnectionWakeUpTimer);
                [self resumeWakeUpTimer];
                [self.delegate connection:self didDisconnectFromHost:self.configuration.origin];
            }
            else {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] DISCONNECTED BECAUSE OF ERROR (STATE: %d)",
                      self.name ? self.name : self, self.state);

                reconnectOnErrorBlock();
            }
        }
        // Disconnection has been done because of other reasons (configuration error / suspending)
        else {

            if (isSuspending) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] SUSPENDED (STATE: %d)",
                      self.name ? self.name : self, self.state);

                PNBitOn(&_state, PNConnectionSuspended);
                [self suspendWakeUpTimer];
                [self stopTimeoutTimer];

                [self.delegate connectionDidSuspend:self];
            }
            else {

                NSString *errorReason = @"";
                if (isDisconnectedOnError) {

                    errorReason = @"BECAUSE OF ERROR ";
                }
                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] DISCONNECTED %@(STATE: %d)",
                      self.name ? self.name : self, errorReason, self.state);

                // Check whether connection has been terminated because of error or not
                if (isDisconnectedOnError) {

                    reconnectOnErrorBlock();
                }
                else {

                    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] NOTIFY DELEGATE ABOUT DISCONNECTION"
                          " (STATE: %d)", self.name ? self.name : self, self.state);
                    self.connectionRetryCount = 0;

                    [self.delegate connection:self didDisconnectFromHost:self.configuration.origin];

                    PNBitOn(&_state, PNConnectionWakeUpTimer);
                    [self resumeWakeUpTimer];
                    [self stopTimeoutTimer];
                }
            }
        }
    }
}

- (void)handleReadStreamHasData {

    [self readStreamContent];
}

- (void)handleWriteStreamCanAcceptData {

    self.writeStreamCanHandleData = YES;

    if (!PNBitsIsOn(self.state, YES, PNConnectionDisconnect, PNByServerRequest, BITS_LIST_TERMINATOR)) {

        [self writeBufferContent];
    }
}

- (void)handleRequestSendingCancelation {

    // Check whether data sending layer is processing some request or not
    if (PNBitIsOn(self.state, PNSendingData) || self.writeBuffer != nil) {

        NSString *interruptedRequestIdentifier = self.writeBuffer.requestIdentifier;

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] UNSCHEDULE REQUEST SENDING (%@)(STATE: %d)",
              self.name ? self.name : self, interruptedRequestIdentifier, self.state);

        self.writeBuffer = nil;
        PNBitOff(&_state, PNSendingData);

        // Notify delegate about that request processing hasn't been completed
        [self.dataSource connection:self didCancelRequestWithIdentifier:interruptedRequestIdentifier];
    }
}

- (void)handleStreamTimeout {

    PNBitsOff(&_state, PNConnectionCleanReconnection, PNByUserRequest, PNByServerRequest, PNByInternalRequest,
              PNConnectionErrorCleanAll, BITS_LIST_TERMINATOR);
    PNBitsOff(&_state, PNConnectionSuspending, PNConnectionSuspended, PNConnectionResuming, BITS_LIST_TERMINATOR);
    PNBitOn(&_state, PNConnectionDisconnected);

    [self reconnect];
}

- (void)handleTimeoutTimer:(NSTimer *)timer {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] HANDLE 'TIMEOUT' TIMER EVENT (STATE: %d)",
          self.name ? self.name : self, self.state);

    [self handleStreamTimeout];
}

- (void)handleWakeUpTimer {

    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] HANDLE 'WAKE UP' TIMER EVENT (STATE: %d)",
          self.name ? self.name : self, self.state);


    // Check whether connection not connected
    if ((![self isConnected] && ![self isConnecting]) || PNBitIsOn(self.state, PNConnectionWakeUpTimer)) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] STILL IN BAD STATE... (STATE: %d)",
              self.name ? self.name : self, self.state);


        unsigned long oldStates = self.state;
        BOOL shouldReconnect = [self.delegate connectionShouldRestoreConnection:self];
        unsigned long newStates = self.state;

        BOOL stateChangedFromOutside = oldStates != newStates && !PNBitIsOn(oldStates, PNByUserRequest) &&
                                       PNBitIsOn(newStates, PNByUserRequest);

        if (!stateChangedFromOutside) {

            // Ask delegate on whether connection should be restored or not
            if (shouldReconnect) {

                BOOL actionByUserRequest = PNBitIsOn(self.state, PNByUserRequest);

                // Mark that since state fixing has been called from 'wake up' timer handler method, all further actions
                // performed on internal code request
                PNBitsOff(&_state, PNByUserRequest, PNByServerRequest, BITS_LIST_TERMINATOR);
                PNBitsOn(&_state, PNByInternalRequest, PNConnectionWakeUpTimer, BITS_LIST_TERMINATOR);

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] HAVE A CHANCE TO FIX ITS STATE (STATE: %d)",
                      self.name ? self.name : self, self.state);

                // Check whether connection should be restored via '-reconnect' method or not
                if ([self shouldReconnect]) {

                    [self reconnect];
                }
                else if (PNBitIsOn(self.state, PNConnectionPrepareToConnect)) {

                    if (actionByUserRequest) {

                        [self connect];
                    }
                    else {

                        [self connectByInternalRequest];
                    }
                }
                else {

                    PNBitsOff(&_state, PNReadStreamCleanAll, PNWriteStreamCleanAll, PNConnectionReconnection,
                            BITS_LIST_TERMINATOR);
                    [self disconnectByInternalRequest];
                }
            }
            else {

                // Looks like connection can't be established, so there can be no 'connecting' state
                PNBitsOff(&_state, PNConnectionConnecting, PNConnectionDisconnecting, BITS_LIST_TERMINATOR);
            }
        }
        else {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] WAKE UP EVENT CANCELED. CONNECTION STATE "
                  "HAS BEEN CHANGED FROM OUTSIDE. (STATE: %d)",
                  self.name ? self.name : self, self.state);
        }
    }
}

- (NSString *)stringifyStreamStatus:(CFStreamStatus)status {

    NSString *stringifiedStatus = @"NOTHING INTERESTING";

    switch (status) {
        case kCFStreamStatusNotOpen:

            stringifiedStatus = @"STREAM NOT OPENED";
            break;
        case kCFStreamStatusOpening:

            stringifiedStatus = @"STREAM IS OPENING";
            break;
        case kCFStreamStatusOpen:

            stringifiedStatus = @"STREAM IS OPENED";
            break;
        case kCFStreamStatusReading:

            stringifiedStatus = @"READING FROM STREAM";
            break;
        case kCFStreamStatusWriting:

            stringifiedStatus = @"WRITING INTO STREAM";
            break;
        case kCFStreamStatusAtEnd:

            stringifiedStatus = @"STREAM CAN'T READ/WRITE DATA";
            break;
        case kCFStreamStatusClosed:

            stringifiedStatus = @"STREAM CLOSED";
            break;
        case kCFStreamStatusError:

            stringifiedStatus = @"STREAM ERROR OCCURRED";
            break;
    }


    return stringifiedStatus;
}

- (void)handleStreamError:(CFErrorRef)error {

    [self handleStreamError:error shouldCloseConnection:NO];
}

- (void)handleStreamError:(CFErrorRef)error shouldCloseConnection:(BOOL)shouldCloseConnection {

    if (error && CFErrorGetCode(error) != 0) {

        NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);
        PNError *errorObject = [self processStreamError:error];

        PNLog(PNLogConnectionLayerErrorLevel, self, @"[CONNECTION::%@] GOT ERROR: %@ (CFNetwork error code: %d "
                "(Domain: %@); connection should be close? %@)(STATE: %d)",
                self.name ? self.name : self, errorObject, CFErrorGetCode(error),
                errorDomain,
                shouldCloseConnection ? @"YES" : @"NO", self.state);

        // Check whether error is caused by SSL issues or not
        if ([self isSecurityTransportError:error]) {

            PNLog(PNLogConnectionLayerErrorLevel, self, @"[CONNECTION::%@] SSL ERROR OCCURRED (STATE: %d)",
                  self.name ? self.name : self, self.state);

            if (![self isInternalSecurityTransportError:error]) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] IS SECURITY LEVEL REDUCTION ALLOWED? %@",
                      self.name ? self.name : self, self.configuration.shouldReduceSecurityLevelOnError ? @"YES" : @"NO");
                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] IS IT ALLOWED TO DISCARD SECURITY SETTINGS? %@",
                      self.name ? self.name : self, self.configuration.canIgnoreSecureConnectionRequirement ? @"YES" : @"NO");
                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CURRENT SSL CONFIGURATION LEVEL: %d",
                      self.name ? self.name : self, self.sslConfigurationLevel);
                
                // Checking whether user allowed to decrease security options and we can do it
                if (self.configuration.shouldReduceSecurityLevelOnError &&
                    self.sslConfigurationLevel == PNConnectionSSLConfigurationStrict) {
                    
                    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] REDUCING SSL REQUIREMENTS",
                          self.name ? self.name : self);

                    shouldCloseConnection = NO;
                    
                    self.sslConfigurationLevel = PNConnectionSSLConfigurationBarelySecure;
                    PNBitOff(&_state, PNConnectionErrorCleanAll);
                    PNBitsOn(&_state, PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR);

                    // Try to reconnect with new SSL security settings
                    [self reconnect];
                }
                // Check whether connection can fallback and use plain HTTP connection w/o SSL
                else if (self.configuration.canIgnoreSecureConnectionRequirement &&
                         self.sslConfigurationLevel == PNConnectionSSLConfigurationBarelySecure) {
                    
                    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] DISCARD SSL",
                          self.name ? self.name : self);

                    shouldCloseConnection = NO;
                    
                    self.sslConfigurationLevel = PNConnectionSSLConfigurationInsecure;
                    PNBitOff(&_state, PNConnectionErrorCleanAll);
                    PNBitsOn(&_state, PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR);
                    
                    // Try to reconnect with new SSL security settings
                    [self reconnect];
                }
            }
            else {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] INTERNAL SSL ERROR OCCURRED (STATE: %d)",
                      self.name ? self.name : self, self.state);

                shouldCloseConnection = NO;
                PNBitOff(&_state, PNConnectionErrorCleanAll);
                PNBitsOn(&_state, PNByInternalRequest, PNConnectionSSL, BITS_LIST_TERMINATOR);
                
                [self reconnect];
            }
        }
        else if ([errorDomain isEqualToString:(NSString *)kCFErrorDomainPOSIX] ||
                [errorDomain isEqualToString:(NSString *)kCFErrorDomainCFNetwork]) {

            PNLog(PNLogConnectionLayerErrorLevel, self, @"[CONNECTION::%@] SOCKET GENERAL ERROR OCCURRED (STATE: %d)",
                  self.name ? self.name : self, self.state);

            // Check whether connection should be reconnected because of critical error
            if ([self isConnectionIssuesError:error]) {

                PNLog(PNLogConnectionLayerErrorLevel, self, @"[CONNECTION::%@] SOCKET ERROR BECAUSE OF INTERNET (STATE: %d)",
                        self.name ? self.name : self, self.state);

                if ([self isConnectionUplinkError:error]) {

                    PNLog(PNLogConnectionLayerErrorLevel, self, @"[CONNECTION::%@] MAYBE UPLINK IS DOWN. (STATE: %d)",
                            self.name ? self.name : self, self.state);
                }
                
                
                if ([self canRetryConnection]) {

                    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CONNECTION RETRY IS POSSIBLE (STATE: %d)",
                          self.name ? self.name : self, self.state);
                    
                    shouldCloseConnection = NO;
                    [self retryConnection];
                }
                else {
                    
                    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CONNECTION RETRY NOT POSSIBLE (STATE: %d)",
                          self.name ? self.name : self, self.state);
                    
                    // Mark that we should init streams close because of critical error
                    shouldCloseConnection = YES;
                }
            }
            
            if ([self isTemporaryError:error]) {
                
                PNBitOff(&_state, PNConnectionErrorCleanAll);
                PNBitsOn(&_state, PNByInternalRequest, PNConnectionSocket, BITS_LIST_TERMINATOR);

                if ([self isServerError:error]) {
                    
                    PNLog(PNLogConnectionLayerErrorLevel, self, @"[CONNECTION::%@] SOCKET GENERAL ERROR BECAUSE OF SERVER ACTIONS (STATE: %d)",
                          self.name ? self.name : self, self.state);
                }
                else {
                    
                    PNLog(PNLogConnectionLayerErrorLevel, self, @"[CONNECTION::%@] SOCKET GENERAL ERROR BECAUSE OF TEMPORARY ISSUES WITH SOCKET (STATE: %d)",
                          self.name ? self.name : self, self.state);
                }
                
                // Checking whether connection is able to perform another connection attempt or not
                if ([self canRetryConnection]) {
                    
                    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CONNECTION RETRY IS POSSIBLE (STATE: %d)",
                          self.name ? self.name : self, self.state);

                    
                    shouldCloseConnection = NO;
                    [self retryConnection];
                }
                else {
                    
                    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CONNECTION RETRY NOT POSSIBLE (STATE: %d)",
                          self.name ? self.name : self, self.state);
                    
                    // Mark that we should init streams close because of critical error
                    shouldCloseConnection = YES;
                }
            }
        }

        if (shouldCloseConnection) {
            
            // Check whether we are tried to establish connection and some error occurred there
            if ([self isConnecting]) {

                shouldCloseConnection = PNBitIsOn(self.state, PNByUserRequest);
                if (!shouldCloseConnection) {

                    PNBitsOn(&_state, PNByInternalRequest, PNConnectionSocket, BITS_LIST_TERMINATOR);

                    [self retryConnection];
                }
                else {
                    
                    PNBitOff(&_state, PNConnectionSocket);
                }
            }
        }


        if (shouldCloseConnection) {

            // Check whether error occurred during data sending or not
            if (PNBitIsOn(self.state, PNConnectionProcessingRequests) && self.writeBuffer) {

                [self handleRequestProcessingError:error];
            }


            if ([self isConnected] && ![self isDisconnecting]) {

                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CLOSING STREAMS BECAUSE OF ERROR (STATE: %d)",
                      self.name ? self.name : self, self.state);

                PNBitsOff(&_state, PNConnectionCleanReconnection, PNReadStreamCleanAll, PNWriteStreamCleanAll,
                                   PNConnectionDisconnect, PNByServerRequest, PNByInternalRequest,PNByUserRequest,
                                   PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR);
                
                self.connectionRetryCount = 0;
                [self.delegate connection:self willDisconnectFromHost:self.configuration.origin withError:errorObject];
                [self disconnectByInternalRequest];
            }
            else if ([self isConnecting]) {
                
                PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] CLOSING STREAMS BECAUSE OF ERROR WHILE TRIED TO CONNECT (STATE: %d)",
                      self.name ? self.name : self, self.state);

                PNBitsOff(&_state, PNConnectionCleanReconnection, PNReadStreamCleanAll, PNWriteStreamCleanAll,
                                   PNConnectionDisconnect, PNByServerRequest, PNByInternalRequest,PNByUserRequest,
                                   PNConnectionWakeUpTimer, PNConnectionSSL, PNConnectionSocket, BITS_LIST_TERMINATOR);
                
                self.connectionRetryCount = 0;
                [self.delegate connection:self connectionDidFailToHost:self.configuration.origin withError:errorObject];
                [self disconnectOnInternalRequest];
            }
        }
    }
}

- (void)handleStreamSetupError {
    
    PNLog(PNLogConnectionLayerErrorLevel, self, @"[CONNECTION::%@] HANDLE STREAM CONFIGURATION FAILURE (STATE: %d)",
          self.name ? self.name : self, self.state);

    // Check whether error occurred while connection attempted to connect to remote services w/o configuration on
    // user request or not
    if (PNBitsIsOn(self.state, YES, PNByUserRequest, PNConnectionPrepareToConnect, BITS_LIST_TERMINATOR)) {

        // Prepare error message which will be sent to connection channel delegate
        PNError *setupError = [PNError errorWithCode:kPNConnectionErrorOnSetup];

        // Connection instance can't operate anymore, notify delegate about it's state
        [self.delegate connection:self connectionDidFailToHost:self.configuration.origin withError:setupError];
    }
    // Looks like error occurred during initial configuration or when reconnection has been called within library
    else {

        __pn_desired_weak __typeof__(self) weakSelf = self;
        int64_t delay = 1;
        if (PNBitsIsOn(self.state, YES, PNConnectionConfiguring, PNConnectionPrepareToConnect, BITS_LIST_TERMINATOR)) {

            delay = kPNConnectionRetryDelay;
        }
        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delay * NSEC_PER_SEC));

        void(^delayedBlock)(void) = ^{

            // Check whether connection is still in bad state before issue connection
            if (PNBitIsOn(weakSelf.state, PNConnectionConfiguring)) {

                if (weakSelf.configurationRetryCount + 1 < kPNMaximumConfigurationRetryCount) {
                    
                    PNLog(PNLogConnectionLayerErrorLevel, weakSelf, @"[CONNECTION::%@] RETRY CONFIGURATION ATTEMPT... (STATE: %d)",
                          weakSelf.name ? weakSelf.name : weakSelf, weakSelf.state);

                    weakSelf.configurationRetryCount++;

                    // Check whether client configuration failed during connection attempt or not
                    if (PNBitsIsOn(weakSelf.state, YES, PNConnectionConfiguring, PNConnectionPrepareToConnect,
                                                        BITS_LIST_TERMINATOR)) {

                        [weakSelf connectByInternalRequest];
                    }
                    else {

                        [weakSelf prepareStreams];
                    }
                }
                // Looks like connection instance can't retry anymore because it reached maximum retry count
                else {
                    
                    PNLog(PNLogConnectionLayerErrorLevel, weakSelf, @"[CONNECTION::%@] CONFIGURATION RETRY COUNT EXCEEDED LIMIT. CANCEL. (STATE: %d)",
                          weakSelf.name ? weakSelf.name : weakSelf, weakSelf.state);

                    weakSelf.configurationRetryCount = 0;
                    weakSelf.connectionRetryCount = 0;

                    // Terminate operation of all streams and buffers (clean up)
                    [weakSelf destroyStreams];

                    PNBitClear(&_state);
                    PNBitOn(&_state, PNConnectionDisconnected);

                    // Connection instance can't operate anymore, notify delegate about it's state
                    [weakSelf.delegate connectionConfigurationDidFail:weakSelf];
                }
            }
        };

        dispatch_after(popTime, dispatch_get_main_queue(), delayedBlock);
    }
}

- (void)handleRequestProcessingError:(CFErrorRef)error {

    if (error && CFErrorGetCode(error) != 0) {

        if (self.writeBuffer && PNBitIsOn(self.state, PNSendingData)) {

            [self.dataSource connection:self didFailToProcessRequestWithIdentifier:self.writeBuffer.requestIdentifier
                              withError:[self processStreamError:error]];
        }
    }
}


#pragma mark - Misc methods

- (void)startTimeoutTimer {

    [self stopTimeoutTimer];

    self.connectionTimeoutTimer = [NSTimer timerWithTimeInterval:kPNConnectionTimeout target:self
                                                        selector:@selector(handleTimeoutTimer:) userInfo:nil
                                                         repeats:NO];

    [[NSRunLoop currentRunLoop] addTimer:self.connectionTimeoutTimer forMode:NSRunLoopCommonModes];
}

- (void)stopTimeoutTimer {

    if ([self.connectionTimeoutTimer isValid]) {

        [self.connectionTimeoutTimer invalidate];
    }

    self.connectionTimeoutTimer = nil;
}

- (void)startWakeUpTimer {

    if (self.wakeUpTimer == NULL) {

        self.wakeUpTimerSuspended = YES;

        dispatch_source_t timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());
        PNDispatchRetain(timerSource);
        self.wakeUpTimer = timerSource;
        __pn_desired_weak __typeof__(self) weakSelf = self;
        dispatch_source_set_event_handler(self.wakeUpTimer, ^{

            [weakSelf handleWakeUpTimer];
        });
        dispatch_source_set_cancel_handler(self.wakeUpTimer, ^{

            PNDispatchRelease(timerSource);
            weakSelf.wakeUpTimerSuspended = NO;
            weakSelf.wakeUpTimer = NULL;
        });

        [self resetWakeUpTimer];
    }

    if (self.isWakeUpTimerSuspended) {

        [self resumeWakeUpTimer];
    }
}

- (void)suspendWakeUpTimer {

    if (self.wakeUpTimer != NULL) {

        if (!self.isWakeUpTimerSuspended) {

            self.wakeUpTimerSuspended = YES;
            dispatch_suspend(self.wakeUpTimer);
        }
    }

    self.wakeUpTimerSuspended = NO;
}

- (void)resumeWakeUpTimer {

    if (self.wakeUpTimer == NULL) {

        [self startWakeUpTimer];
    }
    else {

        if (self.isWakeUpTimerSuspended) {

            self.wakeUpTimerSuspended = NO;
            [self resetWakeUpTimer];
            dispatch_resume(self.wakeUpTimer);
        }
    }
}

- (void)stopWakeUpTimer {

    if (self.wakeUpTimer != NULL) {

        if (self.isWakeUpTimerSuspended) {

            [self resumeWakeUpTimer];
        }
        self.wakeUpTimerSuspended = NO;
        dispatch_source_cancel(self.wakeUpTimer);
    }
}

- (void)resetWakeUpTimer {

    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(kPNWakeUpTimerInterval * NSEC_PER_SEC));
    dispatch_source_set_timer(self.wakeUpTimer, start, (int64_t)(kPNWakeUpTimerInterval * NSEC_PER_SEC), NSEC_PER_SEC);
}

- (CFStreamClientContext)streamClientContext {

    return (CFStreamClientContext){0, (__bridge void *)(self), NULL, NULL, NULL};
}

- (CFMutableDictionaryRef)streamSecuritySettings {

    if (self.configuration.shouldUseSecureConnection && _streamSecuritySettings == NULL &&
        self.sslConfigurationLevel != PNConnectionSSLConfigurationInsecure) {

        // Configure security settings
        _streamSecuritySettings = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 6, NULL, NULL);
        if (self.sslConfigurationLevel == PNConnectionSSLConfigurationStrict) {

            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLLevel, kCFStreamSocketSecurityLevelSSLv3);
            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLAllowsExpiredCertificates, kCFBooleanFalse);
            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLValidatesCertificateChain, kCFBooleanTrue);
            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLAllowsExpiredRoots, kCFBooleanFalse);
            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLAllowsAnyRoot, kCFBooleanFalse);
            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLPeerName, kCFNull);
        }
        else {

            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLLevel, kCFStreamSocketSecurityLevelSSLv3);
            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLAllowsExpiredCertificates, kCFBooleanTrue);
            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLValidatesCertificateChain, kCFBooleanFalse);
            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLAllowsExpiredRoots, kCFBooleanTrue);
            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLAllowsAnyRoot, kCFBooleanTrue);
            CFDictionarySetValue(_streamSecuritySettings, kCFStreamSSLPeerName, kCFNull);
        }
    }
    else if (!self.configuration.shouldUseSecureConnection ||
             self.sslConfigurationLevel == PNConnectionSSLConfigurationInsecure) {

        PNCFRelease(&_streamSecuritySettings);
    }


    return _streamSecuritySettings;
}

- (void)retrieveSystemProxySettings {

    if (self.proxySettings == NULL) {

        PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] FETCHING PROXY CONFIGURATION SETTINGS (STATE: "
              "%d)", self.name ? self.name : self, self.state);

        // Fetch list of all available proxy settings in system
        CFDictionaryRef proxiesList = CFNetworkCopySystemProxySettings();

        if (proxiesList) {

            NSString *scheme = @"http";
            if (self.streamSecuritySettings != NULL) {

                scheme = @"https";
            }

            // Construct URL basing on which system will return list of proxy settings which can be used to open
            // socket
            NSURL *targetHost = [NSURL URLWithString:[NSString stringWithFormat:@"%@://%@", scheme, self.configuration.origin]];

            // Retrieve list of proxy settings which can be used to reach specific resources
            CFArrayRef suitableProxies = CFNetworkCopyProxiesForURL((__bridge CFURLRef)targetHost, proxiesList);

            if (CFArrayGetCount(suitableProxies) > 0) {

                // Retrieve reference on first suitable proxy settings
                CFDictionaryRef suitableProxySettings = CFArrayGetValueAtIndex(suitableProxies, 0);

                if (suitableProxySettings != NULL) {

                    self.proxySettings = CFBridgingRelease(CFDictionaryCreateCopy(kCFAllocatorDefault, suitableProxySettings));
                }
            }
            CFRelease(suitableProxies);
            CFRelease(proxiesList);

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] PROXY CONFIGURATION SETTINGS: %@\n(STATE: "
                  "%d)", self.name ? self.name : self, self.proxySettings, self.state);
        }
        else {

            PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] THERE IS NO PROXY CONFIGURATION IN SYSTEM "
                  "(STATE: %d)", self.name ? self.name : self, self.state);
        }
    }
}

/**
 * Lazy data holder creation
 */
- (NSMutableData *)retrievedData {

    if (_retrievedData == nil) {

        _retrievedData = [NSMutableData dataWithCapacity:kPNStreamBufferSize];
    }


    return _retrievedData;
}

- (NSMutableData *)temporaryRetrievedData {

    if (_temporaryRetrievedData == nil) {

        _temporaryRetrievedData = [NSMutableData dataWithCapacity:kPNStreamBufferSize];
    }


    return _temporaryRetrievedData;
}

- (PNError *)processStreamError:(CFErrorRef)error {

    PNError *errorInstance = nil;

    if (error) {

        NSString *errorDomain = (__bridge NSString *)CFErrorGetDomain(error);

        if ([self isConnectionIssuesError:error]) {

            int errorCode = kPNClientConnectionClosedOnInternetFailureError;
            if (self.writeBuffer != nil && [self.writeBuffer hasData] && self.writeBuffer.isSendingBytes) {

                errorCode = kPNRequestExecutionFailedOnInternetFailureError;
            }

            errorInstance = [PNError errorWithCode:errorCode];
        }
        else if ([self isSecurityTransportError:error]) {

            errorInstance = [PNError errorWithCode:kPNClientConnectionClosedOnSSLNegotiationFailureError];
        }
        else if ([self isTemporaryError:error]) {
            
            NSInteger errorCode = kPNClientConnectionClosedOnSocketsError;
            if ([self isServerError:error]) {
                
                errorCode = kPNClientConnectionClosedOnServerRequestError;
            }
            
            errorInstance = [PNError errorWithCode:errorCode];
        }
        else {

            errorInstance = [PNError errorWithDomain:errorDomain code:CFErrorGetCode(error) userInfo:nil];
        }
    }


    return errorInstance;
}

- (NSString *)stateDescription {

    NSMutableString *connectionState = [NSMutableString stringWithFormat:@"\n[CONNECTION::%@ STATE DESCRIPTION",
                                        self.name ? self.name : self];
    if (PNBitIsOn(self.state, PNReadStreamConfiguring)) {

        [connectionState appendFormat:@"\n- READ STREAM CONFIGURATION..."];
    }
    if (PNBitIsOn(self.state, PNWriteStreamConfiguring)) {

        [connectionState appendFormat:@"\n- WRITE STREAM CONFIGURATION..."];
    }
    if (PNBitIsOn(self.state, PNReadStreamConfigured)) {

        [connectionState appendFormat:@"\n- READ STREAM CONFIGURED"];
    }
    if (PNBitIsOn(self.state, PNWriteStreamConfigured)) {

        [connectionState appendFormat:@"\n- WRITE STREAM CONFIGURED"];
    }
    NSString *actionSource = @"";
    NSString *actionSourceReason = @"";
    if (PNBitIsOn(self.state, PNConnectionWakeUpTimer)) {

        actionSource = @"WAKE UP TIMER";
        actionSourceReason = @" (BY WAKE UP TIMER REQUEST)";
    }
    else if (PNBitIsOn(self.state, PNConnectionSSL)) {

        actionSource = @"SSL LAYER";
        actionSourceReason = @" (BY SSL LAYER REQUEST)";
    }
    else if (PNBitIsOn(self.state, PNConnectionSocket)) {

        actionSource = @"SOCKET LAYER";
        actionSourceReason = @" (BY SOCKET LAYER REQUEST)";
    }
    [connectionState appendFormat:@"\n- ACTION SOURCE: %@...", actionSource];
    if (PNBitIsOn(self.state, PNReadStreamConnecting)) {

        [connectionState appendFormat:@"\n- READ STREAM CONNECTING%@...", actionSourceReason];
    }
    if (PNBitIsOn(self.state, PNWriteStreamConnecting)) {

        [connectionState appendFormat:@"\n- WRITE STREAM CONNECTING%@...", actionSourceReason];
    }
    if (PNBitIsOn(self.state, PNReadStreamConnected)) {

        [connectionState appendFormat:@"\n- READ STREAM CONNECTED"];
    }
    if (PNBitIsOn(self.state, PNWriteStreamConnected)) {

        [connectionState appendFormat:@"\n- WRITE STREAM CONNECTED"];
    }
    if (PNBitIsOn(self.state, PNConnectionPrepareToConnect)) {

        [connectionState appendFormat:@"\n- PREPARING TO CONNECT..."];
    }
    if (PNBitIsOn(self.state, PNByInternalRequest)) {

        [connectionState appendFormat:@"\n- CURRENT ACTION PERFORMED BY INTERNAL REQUEST"];
    }
    if (PNBitIsOn(self.state, PNByUserRequest)) {

        [connectionState appendFormat:@"\n- CURRENT ACTION PERFORMED BY USER REQUEST"];
    }
    if (PNBitIsOn(self.state, PNByServerRequest)) {

        [connectionState appendFormat:@"\n- CONNECTION CLOSE WAS EXPECTED (PROBABLY SERVER DOESN'T SUPPORT "
                "'keep-alive' CONNECTION TYPE)"];
    }
    if (PNBitIsOn(self.state, PNConnectionResuming)) {

        [connectionState appendFormat:@"\n- RESUMING..."];
    }
    if (PNBitIsOn(self.state, PNConnectionReconnect)) {

        [connectionState appendFormat:@"\n- RECONNECTING..."];
    }
    if (PNBitIsOn(self.state, PNReadStreamDisconnecting)) {

        [connectionState appendFormat:@"\n- READ STREAM DISCONNECTING%@...", actionSourceReason];
    }
    if (PNBitIsOn(self.state, PNWriteStreamDisconnecting)) {

        [connectionState appendFormat:@"\n- WRITE STREAM DISCONNECTING%@...", actionSourceReason];
    }
    if (PNBitIsOn(self.state, PNConnectionSuspending)) {

        [connectionState appendFormat:@"\n- SUSPENDING..."];
    }
    if (PNBitIsOn(self.state, PNReadStreamDisconnected)) {

        [connectionState appendFormat:@"\n- READ STREAM DISCONNECTED"];
    }
    if (PNBitIsOn(self.state, PNWriteStreamDisconnected)) {

        [connectionState appendFormat:@"\n- WRITE STREAM DISCONNECTED"];
    }
    if (PNBitIsOn(self.state, PNConnectionReconnectOnDisconnect)) {

        [connectionState appendFormat:@"\n- WAITING FOR DISCONNECTION TO CONNECT BACK"];
    }
    if (PNBitIsOn(self.state, PNConnectionSuspended)) {

        [connectionState appendFormat:@"\n- SUSPENDED"];
    }
    if (PNBitIsOn(self.state, PNConnectionProcessingRequests)) {

        [connectionState appendFormat:@"\n- REQUEST PROCESSING ENABLED"];
    }
    if (PNBitIsOn(self.state, PNSendingData)) {

        [connectionState appendFormat:@"\n- SENDING DATA"];
    }
    if (PNBitIsOn(self.state, PNReadStreamError)) {

        [connectionState appendFormat:@"\n- READ STREAM ERROR"];
    }
    if (PNBitIsOn(self.state, PNWriteStreamError)) {

        [connectionState appendFormat:@"\n- WRITE STREAM ERROR"];
    }


    return connectionState;
}


#pragma mark - Memory management

- (void)prepareForTermination {

    [self stopWakeUpTimer];
    [self stopTimeoutTimer];
}

- (void)dealloc {

    // Closing all streams and free up resources which was allocated for their support
    [self destroyStreams];
    [self stopWakeUpTimer];
    [self stopTimeoutTimer];
    _delegate = nil;
    _proxySettings = nil;
    PNLog(PNLogConnectionLayerInfoLevel, self, @"[CONNECTION::%@] DESTROYED (STATE: %d)",
          _name ? _name : self, _state);

    PNCFRelease(&_streamSecuritySettings);
}

#pragma mark -


@end
