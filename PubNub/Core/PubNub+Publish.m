#import "PubNub+Publish.h"
#import "PNBasePublishRequest+Private.h"
#import "PNAPICallBuilder+Private.h"
#import "PNRequestParameters.h"
#import "PubNub+CorePrivate.h"
#import "PNStatus+Private.h"
#import "PNConfiguration.h"
#import "PNPublishStatus.h"
#import "PNLogMacro.h"
#import "PNHelpers.h"
#import "PNAES.h"


NS_ASSUME_NONNULL_BEGIN

#pragma mark Private interface declaration

@interface PubNub (PublishProtected)


#pragma mark - Composite message publish

/// Send provided Foundation object to the **PubNub** network.
///
/// - Parameters:
///   - message: Object (`NSString`, `NSNumber`, `NSArray`, `NSDictionary`) which will be published.
///   - channel: Name of the channel to which message should be published.
///   - payloads: Dictionary with payloads for different vendors (Apple with `'apns'` key and Google with `'gcm'`).
///   - shouldStore: Whether message should be stored and available with history API or not.
///   - ttl: How long message should be stored in channel's storage. If **0** it will be stored forever or if
///   `nil` - depends from account configuration.
///   - compressed Whether message should be compressed before sending or not.
///   - replicate: Whether message should be replicated across the **PubNub** network and sent simultaneously to all
///   subscribed clients on a channel.
///   - metadata: `NSDictionary` with values which should be used by **PubNub** network to filter messages.
///   - queryParameters: List arbitrary query parameters which should be sent along with original API call.
///   - block: Publish completion block which.
///
/// - Since: 4.8.2
- (void)publish:(nullable id)message
            toChannel:(NSString *)channel
    mobilePushPayload:(nullable NSDictionary<NSString *, id> *)payloads
       storeInHistory:(BOOL)shouldStore
                  ttl:(nullable NSNumber *)ttl
           compressed:(BOOL)compressed
      withReplication:(BOOL)replicate
             metadata:(nullable NSDictionary<NSString *, id> *)metadata
      queryParameters:(nullable NSDictionary *)queryParameters
           completion:(nullable PNPublishCompletionBlock)block;


#pragma mark - Signal

/// Send provided Foundation object to **PubNub** service.
///
/// Provided object will be serialized into JSON string before pushing to **PubNub** service. If client has been
/// configured with cipher key message will be encrypted as well.
///
/// - Parameters:
///   - message Object (`NSString`, `NSNumber`, `NSArray`, `NSDictionary`) which will be sent with signal.
///   - channel: Name of the channel to which signal should be sent.
///   - queryParameters: List arbitrary query parameters which should be sent along with original API call.
///   - block: Signal completion block.
///
/// - Since: 4.9.0
- (void)signal:(id)message
                channel:(NSString *)channel
    withQueryParameters:(nullable NSDictionary *)queryParameters
             completion:(nullable PNSignalCompletionBlock)block;


#pragma mark - Message helper

/// Helper method which allow to calculate resulting message before it will be sent to the **PubNub** network.
///
/// > Note: Size calculation use percent-escaped `message` and all added headers to get full size.
///
/// - Parameters:
///   - message: Message for which size should be calculated.
///   - channel: Name of the channel to which message should be published.
///   - compressMessage: Whether message should be compressed before sending or not.
///   - shouldStore: Whether message should be stored and available with history API or not.
///   - ttl: How long message should be stored in channel's storage. If **0** it will be stored forever or
///   if `nil` - depends from account configuration.
///   - replicate: Whether message should be replicated across the PubNub network and sent simultaneously to all
///   subscribed clients on a channel.
///   - metadata: `NSDictionary` with values which should be used by **PubNub** service to filter messages.
///   - queryParameters: List arbitrary query parameters which should be sent along with original API call.
///   - block: Message size calculation completion block.
///
/// - Since: 4.8.2
- (void)sizeOfMessage:(id)message
            toChannel:(NSString *)channel
           compressed:(BOOL)compressMessage
       storeInHistory:(BOOL)shouldStore
                  ttl:(nullable NSNumber *)ttl
      withReplication:(BOOL)replicate
             metadata:(nullable NSDictionary<NSString *, id> *)metadata
      queryParameters:(nullable NSDictionary *)queryParameters
           completion:(PNMessageSizeCalculationCompletionBlock)block;


#pragma mark - Handlers

/// Handle publish builder perform with block call.
///
/// > Note: Logic moved into separate method because it shared between two almost identical API calls (regular publish
/// and fire which doesn't store message in storage and won't replicate it).
///
/// - Parameters:
///   - flags: List of conditional flags which has been generated by builder on user request.
///   - parameters: List of user-provided data which will be consumed by used API endpoint.
///
/// - Since: 4.5.4
- (void)handlePublishBuilderExecutionWithFlags:(NSArray<NSString *> *)flags parameters:(NSDictionary *)parameters;


#pragma mark - Helpers

/// - Parameters:
///   - message: Object (`NSString`, `NSNumber`, `NSArray`, `NSDictionary`) which will be published.
///   - channel: Name of the channel to which message should be published.
///   - replicate: Whether message should be replicated across the PubNub network and sent simultaneously to all
///   subscribed clients on a channel.
///   - shouldStore: Whether message should be stored and available with history API or not.
///   - ttl How long message should be stored in channel's storage. If **0** it will be stored forever or
///   if `nil` - depends from account configuration.
///   - metadata: `NSDictionary` with values which should be used by the **PubNub** network to filter messages.
///   - sequenceNumber: Next published message sequence number which should be used.
///   - queryParameters: List arbitrary query parameters which should be sent along with original API call.
/// - Returns: Initialized publish request instance.
- (PNRequestParameters *)requestParametersForMessage:(NSString *)message
                                           toChannel:(NSString *)channel
                                          compressed:(BOOL)compressMessage
                                      storeInHistory:(BOOL)shouldStore
                                                 ttl:(nullable NSNumber *)ttl
                                           replicate:(BOOL)replicate
                                            metadata:(nullable NSString *)metadata
                                      sequenceNumber:(NSUInteger)sequenceNumber
                                     queryParameters:(NSDictionary *)queryParameters;

/// Merge user-specified message with push payloads into single message which will be processed on the
/// **PubNub** service.
///
/// In case if aside from `message` has been passed `payloads` this method will merge them into format known by the
/// **PubNub** network and will cause further push distribution to specified vendors.
///
/// - Parameters:
///   - message: Message which should be merged with `payloads`.
///   - payloads: `NSDictionary` with payloads for different push notification services (Apple with `'apns'` key and
///   Google with `'gcm'`).
/// - Returns: Merged message or original message if there is no data in `payloads`.
- (NSDictionary<NSString *, id> *)mergedMessage:(nullable id)message
                          withMobilePushPayload:(nullable NSDictionary<NSString *, id> *)payloads;

/// Try perform encryption of data which should be pushed to **PubNub** services.
///
/// - Parameters:
///   - message: Data which crypto module should try to encrypt.
///   - error: Pointer into which data encryption error will be passed.
/// - Returns: Encrypted Base64-encoded string.
///
/// - Since: 4.16.0
- (nullable NSString *)encryptedMessage:(NSString *)message error:(NSError **)error;

#pragma mark -


@end

NS_ASSUME_NONNULL_END


#pragma mark - Interface implementation

@implementation PubNub (Publish)


#pragma mark - API Builder support

- (PNPublishFileMessageAPICallBuilder * (^)(void))publishFileMessage {
    PNPublishFileMessageAPICallBuilder *builder = nil;
    __weak __typeof(self) weakSelf = self;
    
    builder = [PNPublishFileMessageAPICallBuilder builderWithExecutionBlock:^(NSArray<NSString *> *flags,
                                                                              NSDictionary *parameters) {
        NSString *identifier = parameters[NSStringFromSelector(@selector(fileIdentifier))];
        NSString *filename = parameters[NSStringFromSelector(@selector(fileName))];
        NSString *channel = parameters[NSStringFromSelector(@selector(channel))];
        NSNumber *shouldStore = parameters[NSStringFromSelector(@selector(shouldStore))];
        NSNumber *ttl = parameters[NSStringFromSelector(@selector(ttl))];
        
        if (shouldStore && !shouldStore.boolValue) ttl = nil;
        PNPublishFileMessageRequest *request = [PNPublishFileMessageRequest requestWithChannel:channel
                                                                                fileIdentifier:identifier
                                                                                          name:filename];
        request.metadata = parameters[NSStringFromSelector(@selector(metadata))];
        request.message = parameters[NSStringFromSelector(@selector(message))];
        request.arbitraryQueryParameters = parameters[@"queryParam"];
        request.store = shouldStore ? shouldStore.boolValue : YES;
        request.ttl = ttl.unsignedIntegerValue;
        
        [weakSelf publishFileMessageWithRequest:request completion:parameters[@"block"]];
    }];
    
    return ^PNPublishFileMessageAPICallBuilder * {
        return builder;
    };
}

- (PNPublishAPICallBuilder * (^)(void))publish {
    PNPublishAPICallBuilder *builder = nil;
    __weak __typeof(self) weakSelf = self;
    builder = [PNPublishAPICallBuilder builderWithExecutionBlock:^(NSArray<NSString *> *flags, 
                                                                   NSDictionary *parameters) {
        NSString *channel = parameters[NSStringFromSelector(@selector(channel))];
        NSNumber *shouldStore = parameters[NSStringFromSelector(@selector(shouldStore))];
        NSNumber *ttl = parameters[NSStringFromSelector(@selector(ttl))];
        NSNumber *compressed = parameters[NSStringFromSelector(@selector(compress))];
        NSNumber *replicate = parameters[NSStringFromSelector(@selector(replicate))];
        
        if (shouldStore && !shouldStore.boolValue) ttl = nil;
        PNPublishRequest *request = [PNPublishRequest requestWithChannel:channel];
        request.metadata = parameters[NSStringFromSelector(@selector(metadata))];
        request.payloads = parameters[NSStringFromSelector(@selector(payloads))];
        request.message = parameters[NSStringFromSelector(@selector(message))];
        request.arbitraryQueryParameters = parameters[@"queryParam"];
        request.store = shouldStore ? shouldStore.boolValue : YES;
        request.replicate = replicate ? replicate.boolValue : YES;
        request.compress = compressed.boolValue;
        request.ttl = ttl.unsignedIntegerValue;
                                     
        [weakSelf publishWithRequest:request completion:parameters[@"block"]];
    }];
    
    return ^PNPublishAPICallBuilder * {
        return builder;
    };
}

- (PNPublishAPICallBuilder * (^)(void))fire {
    PNPublishAPICallBuilder *builder = nil;
    __weak __typeof(self) weakSelf = self;
    builder = [PNPublishAPICallBuilder builderWithExecutionBlock:^(NSArray<NSString *> *flags,
                                                                   NSDictionary *parameters) {
        [weakSelf handlePublishBuilderExecutionWithFlags:flags parameters:parameters];
    }];

    [builder setValue:@NO forParameter:NSStringFromSelector(@selector(shouldStore))];
    [builder setValue:@NO forParameter:NSStringFromSelector(@selector(replicate))];
    
    return ^PNPublishAPICallBuilder * {
        return builder;
    };
}

- (PNSignalAPICallBuilder * (^)(void))signal {
    PNSignalAPICallBuilder * builder = nil;
    __weak __typeof(self) weakSelf = self;
    builder = [PNSignalAPICallBuilder builderWithExecutionBlock:^(NSArray<NSString *> *flags,
                                                                  NSDictionary *parameters) {
        id message = parameters[NSStringFromSelector(@selector(message))];
        NSString *channel = parameters[NSStringFromSelector(@selector(channel))];
        NSDictionary *queryParam = parameters[@"queryParam"];
        id block = parameters[@"block"];
        
        [weakSelf signal:message channel:channel withQueryParameters:queryParam completion:block];
    }];
    
    return ^PNSignalAPICallBuilder * {
        return builder;
    };
}

- (PNPublishSizeAPICallBuilder * (^)(void))size {
    PNPublishSizeAPICallBuilder *builder = nil;
    builder = [PNPublishSizeAPICallBuilder builderWithExecutionBlock:^(NSArray<NSString *> *flags,
                                                                       NSDictionary *parameters) {
        id message = parameters[NSStringFromSelector(@selector(message))];
        NSString *channel = parameters[NSStringFromSelector(@selector(channel))];
        NSNumber *shouldStore = parameters[NSStringFromSelector(@selector(shouldStore))];
        NSNumber *ttl = parameters[NSStringFromSelector(@selector(ttl))];
        NSNumber *compressed = parameters[NSStringFromSelector(@selector(compress))];
        NSNumber *replicate = parameters[NSStringFromSelector(@selector(replicate))];
        NSDictionary *metadata = parameters[NSStringFromSelector(@selector(metadata))];
        NSDictionary *queryParam = parameters[@"queryParam"];
        id block = parameters[@"block"];

        if (shouldStore && !shouldStore.boolValue) ttl = nil;
        [self sizeOfMessage:message
                  toChannel:channel
                 compressed:compressed.boolValue
             storeInHistory:(shouldStore ? shouldStore.boolValue : YES)
                        ttl:ttl
            withReplication:(replicate ? replicate.boolValue : YES)
                   metadata:metadata
            queryParameters:queryParam
                 completion:block];
    }];
    
    return ^PNPublishSizeAPICallBuilder * {
        return builder;
    };
}


#pragma mark - Files message

- (void)publishFileMessageWithRequest:(PNPublishFileMessageRequest *)request
                           completion:(PNPublishCompletionBlock)block {
    if (!request.retried) request.sequenceNumber = [self.sequenceManager nextSequenceNumber:YES];
    request.cryptoModule = self.configuration.cryptoModule;
    
    PNLogAPICall(self.logger, @"<PubNub::API> Publish '%@' file message to '%@' channel%@%@%@",
                 (request.identifier ?: @"<error>"),
                 (request.channel ?: @"<error>"),
                 (request.metadata ? [NSString stringWithFormat:@" with metadata (%@)", request.metadata] : @""),
                 (!request.shouldStore ? @" which won't be saved in history" : @""),
                 [NSString stringWithFormat:@": %@", (request.preFormattedMessage ?: @"<error>")]);
    
    __weak __typeof(self) weakSelf = self;
    
    [self performRequest:request withCompletion:^(PNPublishStatus *status) {
        if (block && status.isError) {
            status.retryBlock = ^{
                request.retried = YES;
                [weakSelf publishFileMessageWithRequest:request completion:block];
            };
        }
        
        [weakSelf callBlock:block status:YES withResult:nil andStatus:status];
    }];
}

#pragma mark - Publish with request

- (void)publishWithRequest:(PNPublishRequest *)request completion:(PNPublishCompletionBlock)block {
    if (!request.retried) request.sequenceNumber = [self.sequenceManager nextSequenceNumber:YES];
    request.cryptoModule = self.configuration.cryptoModule;

    PNLogAPICall(self.logger, @"<PubNub::API> Publish%@ message to '%@' channel%@%@%@",
                 (request.shouldCompress ? @" compressed" : @""),
                 (request.channel ?: @"<error>"),
                 (request.metadata ? [NSString stringWithFormat:@" with metadata (%@)", request.metadata] : @""),
                 (!request.shouldStore ? @" which won't be saved in history" : @""),
                 (!request.shouldCompress ? [NSString stringWithFormat:@": %@",
                                             (request.message ?: @"<error>")] : @"."));
    
    __weak __typeof(self) weakSelf = self;
    
    [self performRequest:request withCompletion:^(PNPublishStatus *status) {
        if (block && status.isError) {
            status.retryBlock = ^{
                request.retried = YES;
                [weakSelf publishWithRequest:request completion:block];
            };
        }
        
        [weakSelf callBlock:block status:YES withResult:nil andStatus:status];
    }];
}


#pragma mark - Plain message publish

- (void)publish:(id)message toChannel:(NSString *)channel withCompletion:(PNPublishCompletionBlock)block {
    [self publish:message toChannel:channel withMetadata:nil completion:block];
}

- (void)publish:(id)message
       toChannel:(NSString *)channel
    withMetadata:(NSDictionary<NSString *, id> *)metadata
      completion:(PNPublishCompletionBlock)block {
    [self publish:message toChannel:channel compressed:NO withMetadata:metadata completion:block];
}

- (void)publish:(id)message
         toChannel:(NSString *)channel
        compressed:(BOOL)compressed
    withCompletion:(PNPublishCompletionBlock)block {
    [self publish:message toChannel:channel compressed:compressed withMetadata:nil completion:block];
}

- (void)publish:(id)message
       toChannel:(NSString *)channel
      compressed:(BOOL)compressed
    withMetadata:(NSDictionary<NSString *, id> *)metadata
      completion:(PNPublishCompletionBlock)block {
    [self publish:message
         toChannel:channel
    storeInHistory:YES
        compressed:compressed
      withMetadata:metadata
        completion:block];
}

- (void)publish:(id)message
         toChannel:(NSString *)channel
    storeInHistory:(BOOL)shouldStore
    withCompletion:(PNPublishCompletionBlock)block {
    [self publish:message toChannel:channel storeInHistory:shouldStore withMetadata:nil completion:block];
}

- (void)publish:(id)message
         toChannel:(NSString *)channel
    storeInHistory:(BOOL)shouldStore
      withMetadata:(NSDictionary<NSString *, id> *)metadata
        completion:(PNPublishCompletionBlock)block {
    [self publish:message
         toChannel:channel
    storeInHistory:shouldStore
        compressed:NO
      withMetadata:metadata
        completion:block];
}

- (void)publish:(id)message
         toChannel:(NSString *)channel
    storeInHistory:(BOOL)shouldStore
        compressed:(BOOL)compressed
    withCompletion:(PNPublishCompletionBlock)block {
    [self publish:message
         toChannel:channel
    storeInHistory:shouldStore
        compressed:compressed
      withMetadata:nil
        completion:block];
}

- (void)publish:(id)message
         toChannel:(NSString *)channel
    storeInHistory:(BOOL)shouldStore
        compressed:(BOOL)compressed
      withMetadata:(NSDictionary<NSString *, id> *)metadata
        completion:(PNPublishCompletionBlock)block {
    [self publish:message
            toChannel:channel
    mobilePushPayload:nil
       storeInHistory:shouldStore
           compressed:compressed
         withMetadata:metadata
           completion:block];
}


#pragma mark - Composite message publish

- (void)publish:(id)message
            toChannel:(NSString *)channel
    mobilePushPayload:(NSDictionary<NSString *, id> *)payloads
       withCompletion:(PNPublishCompletionBlock)block {
    [self publish:message toChannel:channel mobilePushPayload:payloads withMetadata:nil completion:block];
}

- (void)publish:(id)message
            toChannel:(NSString *)channel
    mobilePushPayload:(NSDictionary<NSString *, id> *)payloads
         withMetadata:(NSDictionary<NSString *, id> *)metadata
           completion:(PNPublishCompletionBlock)block {
    [self publish:message
            toChannel:channel
    mobilePushPayload:payloads
           compressed:NO
         withMetadata:metadata
           completion:block];
}

- (void)publish:(id)message
            toChannel:(NSString *)channel
    mobilePushPayload:(NSDictionary<NSString *, id> *)payloads
           compressed:(BOOL)compressed
       withCompletion:(PNPublishCompletionBlock)block {
    [self publish:message
            toChannel:channel
    mobilePushPayload:payloads
           compressed:compressed
         withMetadata:nil
           completion:block];
}

- (void)publish:(id)message
            toChannel:(NSString *)channel
    mobilePushPayload:(NSDictionary<NSString *, id> *)payloads
           compressed:(BOOL)compressed
         withMetadata:(NSDictionary<NSString *, id> *)metadata
           completion:(PNPublishCompletionBlock)block {
    [self publish:message
            toChannel:channel
    mobilePushPayload:payloads
       storeInHistory:YES
           compressed:compressed
         withMetadata:metadata
           completion:block];
}

- (void)publish:(id)message
            toChannel:(NSString *)channel
    mobilePushPayload:(NSDictionary<NSString *, id> *)payloads
       storeInHistory:(BOOL)shouldStore
       withCompletion:(PNPublishCompletionBlock)block {
    [self publish:message
            toChannel:channel
    mobilePushPayload:payloads
       storeInHistory:shouldStore
         withMetadata:nil
           completion:block];
}

- (void)publish:(id)message
            toChannel:(NSString *)channel
    mobilePushPayload:(NSDictionary<NSString *, id> *)payloads
       storeInHistory:(BOOL)shouldStore
         withMetadata:(NSDictionary<NSString *, id> *)metadata
           completion:(PNPublishCompletionBlock)block {
    [self publish:message
            toChannel:channel
    mobilePushPayload:payloads
       storeInHistory:shouldStore
           compressed:NO
         withMetadata:metadata
           completion:block];
}

- (void)publish:(id)message
            toChannel:(NSString *)channel
    mobilePushPayload:(NSDictionary<NSString *, id> *)payloads
       storeInHistory:(BOOL)shouldStore
           compressed:(BOOL)compressed
       withCompletion:(PNPublishCompletionBlock)block {
    [self publish:message
            toChannel:channel
    mobilePushPayload:payloads
       storeInHistory:shouldStore
           compressed:compressed
         withMetadata:nil
           completion:block];
}

- (void)publish:(id)message
            toChannel:(NSString *)channel
    mobilePushPayload:(NSDictionary<NSString *, id> *)payloads
       storeInHistory:(BOOL)shouldStore
           compressed:(BOOL)compressed
         withMetadata:(NSDictionary<NSString *, id> *)metadata
           completion:(PNPublishCompletionBlock)block {
    [self publish:message
            toChannel:channel
    mobilePushPayload:payloads
       storeInHistory:shouldStore
                  ttl:nil
           compressed:compressed
      withReplication:YES
             metadata:metadata
      queryParameters:nil
           completion:block];
}

- (void)publish:(id)message
            toChannel:(NSString *)channel
    mobilePushPayload:(NSDictionary<NSString *, id> *)payloads
       storeInHistory:(BOOL)shouldStore
                  ttl:(NSNumber *)ttl
           compressed:(BOOL)compressed
      withReplication:(BOOL)replicate
             metadata:(NSDictionary<NSString *, id> *)metadata
      queryParameters:(NSDictionary *)queryParameters
           completion:(PNPublishCompletionBlock)block {

    PNPublishRequest *request = [PNPublishRequest requestWithChannel:channel];
    request.arbitraryQueryParameters = queryParameters;
    request.ttl = ttl.unsignedIntegerValue;
    request.replicate = replicate;
    request.compress = compressed;
    request.metadata = metadata;
    request.payloads = payloads;
    request.store = shouldStore;
    request.message = message;
                                 
    [self publishWithRequest:request completion:block];
}


#pragma mark - Signal

- (void)signal:(id)message channel:(NSString *)channel withCompletion:(PNSignalCompletionBlock)block {
    [self signal:message channel:channel withQueryParameters:nil completion:block];
}

- (void)signal:(id)message
                channel:(NSString *)channel
    withQueryParameters:(NSDictionary *)queryParameters
             completion:(PNSignalCompletionBlock)block {
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    __weak __typeof(self) weakSelf = self;
    
    if (@available(macOS 10.10, iOS 8.0, *)) {
        if (self.configuration.applicationExtensionSharedGroupIdentifier) queue = dispatch_get_main_queue();
    }
    
    dispatch_async(queue, ^{
        __strong __typeof__(weakSelf) strongSelf = weakSelf;
        NSError *signalError = nil;
        NSString *messageForSignal = [PNJSON JSONStringFrom:message withError:&signalError];
        PNRequestParameters *parameters = [PNRequestParameters new];
        [parameters addQueryParameters:queryParameters];
        
        if (channel.length) {
            [parameters addPathComponent:[PNString percentEscapedString:channel] forPlaceholder:@"{channel}"];
        }
        
        if (([messageForSignal isKindOfClass:[NSString class]] && messageForSignal.length) || messageForSignal) {
            [parameters addPathComponent:[PNString percentEscapedString:messageForSignal] forPlaceholder:@"{message}"];
        }
        
        PNLogAPICall(strongSelf.logger, @"<PubNub::API> Signal to '%@' channel.", (channel ?: @"<error>"));
        
        [strongSelf processOperation:PNSignalOperation
                      withParameters:parameters
                                data:nil
                     completionBlock:^(PNStatus *status) {
                         
            if (status.isError) {
                status.retryBlock = ^{
                    [weakSelf signal:message
                             channel:channel
                 withQueryParameters:queryParameters
                          completion:block];
                };
            }

            [weakSelf callBlock:block status:YES withResult:nil andStatus:status];
        }];
    });
}


#pragma mark - Message helper

- (void)sizeOfMessage:(id)message
            toChannel:(NSString *)channel
       withCompletion:(PNMessageSizeCalculationCompletionBlock)block {
    [self sizeOfMessage:message toChannel:channel withMetadata:nil completion:block];
}

- (void)sizeOfMessage:(id)message
            toChannel:(NSString *)channel
         withMetadata:(NSDictionary<NSString *, id> *)metadata
           completion:(PNMessageSizeCalculationCompletionBlock)block {
    [self sizeOfMessage:message toChannel:channel compressed:NO withMetadata:metadata completion:block];
}

- (void)sizeOfMessage:(id)message
            toChannel:(NSString *)channel
           compressed:(BOOL)compressMessage
       withCompletion:(PNMessageSizeCalculationCompletionBlock)block {
    [self sizeOfMessage:message toChannel:channel compressed:compressMessage withMetadata:nil completion:block];
}

- (void)sizeOfMessage:(id)message
            toChannel:(NSString *)channel
           compressed:(BOOL)compressMessage
         withMetadata:(NSDictionary<NSString *, id> *)metadata
           completion:(PNMessageSizeCalculationCompletionBlock)block {
    [self sizeOfMessage:message
              toChannel:channel
             compressed:compressMessage
         storeInHistory:YES
           withMetadata:metadata
             completion:block];
}

- (void)sizeOfMessage:(id)message
            toChannel:(NSString *)channel
       storeInHistory:(BOOL)shouldStore
       withCompletion:(PNMessageSizeCalculationCompletionBlock)block {
    [self sizeOfMessage:message
              toChannel:channel
         storeInHistory:shouldStore
           withMetadata:nil
             completion:block];
}

- (void)sizeOfMessage:(id)message
            toChannel:(NSString *)channel
       storeInHistory:(BOOL)shouldStore
         withMetadata:(NSDictionary<NSString *, id> *)metadata
           completion:(PNMessageSizeCalculationCompletionBlock)block {
    [self sizeOfMessage:message
              toChannel:channel
             compressed:NO
         storeInHistory:shouldStore
           withMetadata:metadata
             completion:block];
}

- (void)sizeOfMessage:(id)message
            toChannel:(NSString *)channel
           compressed:(BOOL)compressMessage
       storeInHistory:(BOOL)shouldStore
       withCompletion:(PNMessageSizeCalculationCompletionBlock)block {
    [self sizeOfMessage:message
              toChannel:channel
             compressed:compressMessage
         storeInHistory:shouldStore
           withMetadata:nil
             completion:block];
}

- (void)sizeOfMessage:(id)message
            toChannel:(NSString *)channel
           compressed:(BOOL)compressMessage
       storeInHistory:(BOOL)shouldStore
         withMetadata:(NSDictionary<NSString *, id> *)metadata
           completion:(PNMessageSizeCalculationCompletionBlock)block {
    [self sizeOfMessage:message
              toChannel:channel
             compressed:compressMessage
         storeInHistory:shouldStore
                    ttl:nil
        withReplication:YES
               metadata:metadata
        queryParameters:nil
             completion:block];
}

- (void)sizeOfMessage:(id)message
            toChannel:(NSString *)channel
           compressed:(BOOL)compressMessage
       storeInHistory:(BOOL)shouldStore
                  ttl:(NSNumber *)ttl
      withReplication:(BOOL)replicate
             metadata:(NSDictionary<NSString *, id> *)metadata
      queryParameters:(NSDictionary *)queryParameters
           completion:(PNMessageSizeCalculationCompletionBlock)block {
    if (block) {
        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
        NSUInteger nextSequenceNumber = [self.sequenceManager nextSequenceNumber:NO];
        __weak __typeof(self) weakSelf = self;

        if (@available(macOS 10.10, iOS 8.0, *)) {
            if (self.configuration.applicationExtensionSharedGroupIdentifier) queue = dispatch_get_main_queue();
        }
        
        dispatch_async(queue, ^{
            NSError *publishError = nil;
            NSString *messageForPublish = [PNJSON JSONStringFrom:message withError:&publishError];
            NSString *metadataForPublish = nil;
            NSData *publishData = nil;
            
            // Silence static analyzer warnings.
            // Code is aware about this case and at the end will simply call on 'nil' object method.
            // In most cases if referenced object become 'nil' it mean what there is no more need in
            // it and probably whole client instance has been deallocated.
            #pragma clang diagnostic push
            #pragma clang diagnostic ignored "-Warc-repeated-use-of-weak"
            // Encrypt message in case if serialization to JSON was successful.
            if (!publishError && weakSelf.configuration.cryptoModule) {
                messageForPublish = [weakSelf encryptedMessage:messageForPublish error:&publishError];

            }
            if (metadata) metadataForPublish = [PNJSON JSONStringFrom:metadata withError:&publishError];
            
            PNRequestParameters *parameters = [weakSelf requestParametersForMessage:messageForPublish
                                                                          toChannel:channel
                                                                         compressed:compressMessage
                                                                     storeInHistory:shouldStore
                                                                                ttl:ttl
                                                                          replicate:replicate
                                                                           metadata:metadataForPublish
                                                                     sequenceNumber:nextSequenceNumber
                                                                    queryParameters:queryParameters];
            
            if (compressMessage) {
                NSData *messageData = [messageForPublish dataUsingEncoding:NSUTF8StringEncoding];
                NSData *compressedBody = [PNGZIP GZIPDeflatedData:messageData];
                publishData = (compressedBody?: [@"" dataUsingEncoding:NSUTF8StringEncoding]);
            }
            
            NSInteger size = [weakSelf packetSizeForOperation:PNPublishOperation
                                               withParameters:parameters
                                                         data:publishData];
            
            pn_dispatch_async(weakSelf.callbackQueue, ^{
                block(size);
            });
            #pragma clang diagnostic pop
        });
    }
}


#pragma mark - Handlers

- (void)handlePublishBuilderExecutionWithFlags:(NSArray<NSString *> *)flags parameters:(NSDictionary *)parameters {
    id message = parameters[NSStringFromSelector(@selector(message))];
    NSString *channel = parameters[NSStringFromSelector(@selector(channel))];
    NSDictionary *payloads = parameters[NSStringFromSelector(@selector(payloads))];
    NSNumber *shouldStore = parameters[NSStringFromSelector(@selector(shouldStore))];
    NSNumber *ttl = parameters[NSStringFromSelector(@selector(ttl))];
    if (shouldStore && !shouldStore.boolValue) { ttl = nil; }
    NSNumber *compressed = parameters[NSStringFromSelector(@selector(compress))];
    NSNumber *replicate = parameters[NSStringFromSelector(@selector(replicate))];
    NSDictionary *metadata = parameters[NSStringFromSelector(@selector(metadata))];
    
    [self publish:message
        toChannel:channel
    mobilePushPayload:payloads
   storeInHistory:(shouldStore ? shouldStore.boolValue : YES)
              ttl:ttl
       compressed:compressed.boolValue
  withReplication:(replicate ? replicate.boolValue : YES)
         metadata:metadata
  queryParameters:parameters[@"queryParam"]
       completion:parameters[@"block"]];
}


#pragma mark - Misc

- (PNRequestParameters *)requestParametersForMessage:(NSString *)message
                                           toChannel:(NSString *)channel
                                          compressed:(BOOL)compressMessage
                                      storeInHistory:(BOOL)shouldStore
                                                 ttl:(NSNumber *)ttl
                                           replicate:(BOOL)replicate
                                            metadata:(NSString *)metadata
                                      sequenceNumber:(NSUInteger)sequenceNumber
                                     queryParameters:(NSDictionary *)queryParameters {
    PNRequestParameters *parameters = [PNRequestParameters new];
    [parameters addQueryParameters:queryParameters];

    if (channel.length) {
        [parameters addPathComponent:[PNString percentEscapedString:channel] forPlaceholder:@"{channel}"];
    }

    if (!shouldStore) [parameters addQueryParameter:@"0" forFieldName:@"store"];
    if (ttl) [parameters addQueryParameter:ttl.stringValue forFieldName:@"ttl"];
    if (!replicate) [parameters addQueryParameter:@"true" forFieldName:@"norep"];

    if (([message isKindOfClass:[NSString class]] && message.length) || message) {
        id targetMessage = !compressMessage ? [PNString percentEscapedString:message] : @"";
        [parameters addPathComponent:targetMessage forPlaceholder:@"{message}"];
    }
    
    if ([metadata isKindOfClass:[NSString class]] && metadata.length) {
        [parameters addQueryParameter:[PNString percentEscapedString:metadata] forFieldName:@"meta"];
    }
    
    [parameters addQueryParameter:@(sequenceNumber).stringValue forFieldName:@"seqn"];
    
    return parameters;
}

- (NSDictionary<NSString *, id> *)mergedMessage:(id)message
                          withMobilePushPayload:(NSDictionary<NSString *, id> *)payloads {
    // Convert passed message to mutable dictionary into which required by push notification
    // delivery service provider data will be added.
    NSDictionary *originalMessage = message ?: @{};
    if (message && ![message isKindOfClass:[NSDictionary class]]) {
        originalMessage = @{ @"pn_other": message };
    }

    NSMutableDictionary *mergedMessage = [originalMessage mutableCopy];

    for (NSString *pushProviderType in payloads) {
        id payload = payloads[pushProviderType];
        NSString *providerKey = pushProviderType;

        if (![pushProviderType hasPrefix:@"pn_"]) {
            providerKey = [NSString stringWithFormat:@"pn_%@", pushProviderType];

            if ([pushProviderType isEqualToString:@"aps"]) {
                payload = @{pushProviderType:payload};
                providerKey = @"pn_apns";
            }
        }

        [mergedMessage setValue:payload forKey:providerKey];
    }
    
    return [mergedMessage copy];
}

- (NSString *)encryptedMessage:(NSString *)message error:(NSError **)error {
    NSString *encryptedMessage = message;
    NSData *JSONData = [message dataUsingEncoding:NSUTF8StringEncoding];
    PNResult<NSData *> *encryptionResult = [self.configuration.cryptoModule encryptData:JSONData];

    if (encryptionResult.isError) {
        *error = encryptionResult.error;
        encryptedMessage = nil;
    } else {
        NSString *base64 = [encryptionResult.data base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];
        encryptedMessage = [PNJSON JSONStringFrom:base64 withError:error];
    }
    
    return encryptedMessage;
}

#pragma mark -


@end
